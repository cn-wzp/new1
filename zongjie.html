<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>HTML+CSS+JS总结</title>
    <link rel="stylesheet" type="text/css" href="css/zongjie.css">
</head>

<body>
    <div>
        <div class="header">
            <h1>认识HTML</h1>
            <h2>html结构</h2>
            <h3>基本标签</h3>
            <ul>
                <li>html标签：告诉浏览器这是一个HTML文档，其他标签都写在HTLML开始和结束标签中间。</li>
                <li>head标签：给网站添加一些配置 里面的内容用户是看不到的。</li>
                <li>title标签：用于网站的标题，title标签必须在head标签里面。</li>
                <li>body标签：要显示的内容放在html标签中，一对html标签中只能有一对body。</li>
            </ul>
        </div>
        <hr />
        <div class="header">
            <h2>标签分类</h2>
            <h3>单标签</h3>
            <ul>
                <li>只有开始标签没有结束标签。例如：<br /><textarea><!DOCTYPE html><meta><link></textarea></li>
            </ul>
            <hr />
            <h3>双标签</h3>
            <ul>
                <li>有开始标签和结束标签。例如：<br />
                    <textarea><html></html><head></head><body></body><h></h><ul></ul><li></li>等等
                    </textarea>
                </li>
            </ul>
            <hr />
            <h3>嵌套关系</h3>
            <ul>
                <li>父子/上下级：</li>

                <textarea>
                <html>
                    <head>
                        <mete>
                        <title>子元素</title>
                    </head>
                    <body>
                    </body>
                </html>
            </textarea>
            </ul>
        </div>
        <hr />
        <div class="header">
            <h1>基础标签</h1>
            <h2>H标签</h2>
            <ul>
                <li>作用：</li>
                <ul>
                    <li>网页定义标题</li>
                </ul>
                <li>注意：</li>
                <ul>
                    <li>H标签是定义标题的不是修改文本的</li>
                    <li>H标签一共6个从H1~H6</li>
                    <LI>被H标签包裹的内容会单独占一行</LI>
                    <li>H1最大，H6最小</li>
                </ul>
            </ul>
            <hr />
            <h2>P标签</h2>
            <ul>
                <li>作用：</li>
                <ul>
                    <li>浏览器的段落</li>
                </ul>
                <li>注意：</li>
                <ul>
                    <li>在浏览器会单独占一行</li>
                </ul>
            </ul>
            <hr />
            <h2>Hr标签</h2>
            <ul>
                <li>作用：</li>
                <ul>
                    <li>在浏览器显示一条分割线</li>
                </ul>
                <li>注意：</li>
                <ul>
                    <li>Hr标签会修改样式</li>
                </ul>
            </ul>
            <hr />
            <h2>img标签</h2>
            <ul>
                <li>作用：</li>
                <ul>
                    <li>在网页上插入一张照片</li>
                </ul>
                <li>注意：</li>
                <ul>
                    <li>IMG标签默认不是单独占一行</li>
                    <li>想让图片等比拉伸只写高度和宽度就可以</li>
                </ul>
                <li>用法：</li>
                <ul>
                    <li>src:地址</li>
                    <li>alt:文本。在SRC指定的路径找不到文件，就会显示alt的文本</li>
                    <li>title：悬停文本。鼠标移动到图片上时显示的文本</li>
                    <li>height:高度</li>
                    <li>width:宽度</li>
                </ul>
            </ul>
            <hr />
            <h2>Br标签</h2>
            <ul>
                <li>作用：</li>
                <ul>
                    <li>换行</li>
                </ul>
                <li>注意：</li>
                <ul>
                    <li>br的意思不是段落换行</li>
                </ul>
            </ul>
            <hr />
            <h2>a标签</h2>
            <ul>
                <li>作用：</li>
                <ul>
                    <li>从一个页面链接到另一个页面</li>
                </ul>
                <li>注意：</li>
                <ul>
                    <li>a标签之间一定要写上文字，用于跳转超链接</li>
                </ul>
                <li>用法：</li>
                <ul>
                    <li>href:指定跳转目标链接</li>
                    <li>target:告诉浏览器是否需要保留原始界面，_blank保留，_self不保留</li>
                    <li>title:悬停文本</li>
                </ul>
                <li>base标签和a标签结合使用</li>
                <ul>
                    <li>如果每个a标签都想在新页面中打开,那么逐个设置a标签的target属性比较麻烦, 这时我们可以使用base和a标签结合的方式,一次性设置有a标签都在新页面中打开</li>
                    <li>格式:
                        < base target="_blank" />
                    </li>
                </ul>
                <li>注意：</li>
                <ul>
                    <li>base必须嵌套在head标签里面</li>
                    <li>如果标签上指定了target,base中也指定了target,那么会按照标签上指定的来执行</li>
                </ul>
            </ul>
        </div>
        <hr />
        <div class="header">
            <h1>列表标签</h1>
            <h2>无序列表</h2>
            <ul>
                <li>作用:给一堆内容添加无序列表语义(一个没有先后顺序整体), 列表中的条目是不分先后</li>
                <li>格式：</li>
                <ul>
                    <li>
                        < h4>选择居住城市(CN)
                            < /h4> <br />
                                < ul><br />
                                    < li>北京
                                        < /li><br />
                                            < li>上海
                                                < /li><br />
                                                    < li>广州
                                                        < /li><br />
                                                            < li>铁岭
                                                                < /li><br />
                                                                    < /ul>
                </ul>
            </ul>
            <ul>
                <li>ul应用的场景</li>
                <ul>
                    <li>导航条</li>
                    <li>各种列表</li>
                </ul>
            </ul>
        </div>
        <hr />
        <div class="header">
            <h2>有序列表</h2>
            <ul>
                <li>作用： 给一堆内容添加有序列表语义(一个有顺序整体), 列表中的条目有先后之分</li>
                <li>格式:</li>
                <ul>
                    <li>
                        < h4>选择居住城市(CN)
                            < /h4><br />
                                < ol><br />
                                    < li>北京
                                        < /li><br />
                                            < li>上海
                                                < /li><br />
                                                    < li>广州
                                                        < /li><br />
                                                            < li>铁岭
                                                                < /li><br />
                                                                    < /ol><br />
                    </li>
                </ul>
                <li>ol应用场景</li>
                <ul>
                    <li>xxx排行榜</li>
                </ul>
                <li>注意:</li>
                <ul>
                    <li>ol和ul就是语义不一样，怎么使用都是一样的以及注意点都一样</li>
                    <li>其实ul还有两个常见属性start、type属性, 可以修改先导符号的样式和序号</li>
                </ul>
            </ul>
        </div>
        <hr />
        <div class="header">
            <h2>定义列表</h2>
            <ul>
                <li>作用: 给一堆内容添加列表语义, 通过dt罗列出列表的条目, 然后再通过dd给每个条目进行相应的描述</li>
                <li>格式</li>
                <ul>
                    <li>dt定义标题</li>
                    <li>dd定义描述信息</li>
                    <li>格式：</li>
                    <li>
                        < dl><br />
                            < dt>北京
                                < /dt><br />
                                    < dd>国家的首都, 看升国旗的地方
                                        < /dd><br />
                                            < dt>上海
                                                < /dt><br />
                                                    < dd>魔都, 遍地是黄金的地方
                                                        < /dd><br />
                                                            < /dl><br />
                    </li>
                </ul>
                <li>dl应用场景：</li>
                <ul>
                    <li>网站底部相关信息</li>
                    <li>但凡看到一堆内容都是用于描述某一个内容的时候就要想到dl</li>
                </ul>
                <li>注意：</li>
                <ul>
                    <li>由于dl和dt、dd是一个整体, 所以dl里面不推荐包裹其它标签</li>
                    <li>dd和dt和li标签一样是容器标签, 里面可以添加任意标签</li>
                    <li>定义列表非常灵活, 可以给一个dt配置多个dd, 但是最好不要出现多个dt对应一个dd, dd的语义是描述离它最近的一个dt, 所以其它dt相当于没有描述, 而定义列表存在的意义就是既可以列出每一个条目又可以对每一个条目进行描述
                    </li>
                    <li>定义列表非常灵活, 可以将多个dt+dd组合拆分为多个dl</li>
                </ul>
            </ul>
        </div>
        <hr />
        <div class="header">
            <h2>表格标签</h2>
            <ul>
                <li>格式：</li>
                <ul>
                    <li>table定义表格</li>
                    <li>tr定义行</li>
                    <li>td定义单元格</li>
                    <li>
                        < table><br />
                            < tr><br />
                                < td>
                                    < /td><br />
                                        < td>
                                            < /td><br />
                                                < /tr><br />
                                                    < tr><br />
                                                        < td>
                                                            < /td><br />
                                                                < td>
                                                                    < /td><br />
                                                                        < /tr><br />
                                                                            < /table><br />
                    </li>
                </ul>
            </ul>
        </div>
        <hr />
        <div class="header">
            <h2>表格中的属性</h2>
            <ul>
                <li>border: 默认情况下表格的边框宽度为0看不到, 通过border属性给表格指定边框宽度</li>
                <li>width: 默认情况下表格的宽度是由内容自动计算出来的, 可以通过width属性指定表格的宽度</li>
                <li>height:默认情况下表格的高度是由内容自动计算出来的, 可以通过height属性指定表格的高度</li>
                <li>cellspacing: 外边距. 默认情况下单元格之间有2个像素的间隙, 可以通过cellpadding指定表格之间的间隙</li>
                <li>cellpadding: 内边距. 默认情况下单元格边缘距离内容有1个像素的内边距, 可以通过cellpadding属性指定单元格边缘和内容之间的内边距</li>
                <li>align: 规定表格相对周围元素的对齐方式, 它的取值有center、left、right</li>
                <ul>
                    <li>给table设置align属性, 是让表格在浏览器中居左/居右/居中</li>
                    <li>给tr设置align属性, 是让当前行中所有内容居左/居右/居中</li>
                    <li>给td设置align属性,是让当前单元格中所有内容居左/居右/居中</li>
                    <li>如果td中设置了align属性, tr中也设置了align属性, 那么单元格中的内容会按照td中设置的来对齐</li>
                </ul>
                <br />
                <li>valign: 规定表格相对周围元素的对齐方式, 它的取值有center、left、right</li>
                <ul>
                    <li>给Table设置valign属性，无效</li>
                </ul>
                <li>bgcolor:规定表格的背景颜色</li>
                <ul>
                    <li>给table设置bgcolor属性, 是给整个表格设置背景颜色</li>
                    <li>给tr设置bgcolor属性, 是给当前行设置背景颜色</li>
                    <li>给td设置bgcolor属性, 是给当前单元格设置背景颜色</li>
                </ul>
            </ul>
        </div>
        <hr />
        <div class="header">
            <h2>表格中的其他标签</h2>
            <ul>
                <li>表单中有两种类型的单元格, 一种是标准单元格td, 一种是表头单元格th</li>
                <li>th标签: 给每一列设置标题, 单元格中的内容会自动加粗，居中</li>
                <li>caption标签:给整个表格设置标题</li>
                <ul>
                    <li>一定要嵌套在talbe标签内部才有效</li>
                </ul>
            </ul>
            <ul>
                <li>thead标签:用来存放当前列的表头, 如果没有加css页面默认将表头中的高度设置变小</li>
                <li>tbody标签:一般用来存放页面中的主体数据, 如果不写会自动加上</li>
                <li>tfoot标签:用来存放表格的页脚（脚注或表注), 如果没有加css页面默认将表头中的高度设置变小, 一般不会出现</li>
            </ul>
        </div>
        <hr />
        <div class="header">
            <h2>表单标签</h2>
            <ul>
                <li>作用: 用于收集用户信息, 让用户填写、选择相关信息</li>
                <li>格式:</li><br />
                <textarea>
                    < form><br />
                        所有的表单内容，都要写在form标签里面<br />
                    < /form><br />
                </textarea>
                <li>注意事项:</li>
                <ul>
                    <li>所有的表单内容，都要写在form标签里面</li>
                    <li>form标签中有两个比较重要的属性action和method</li>
                </ul>
            </ul>
            <hr />
            <h2>input标签</h2>
            <ul>
                <li>如果说td是表格最核心的标签, 那么input就是表单最核心的标签. nput标签有一个type属性, 这个属性 有很多类型的取值, 取值的不同就决定了input标签的功能和外观不同</li>
                <li>明文输入框</li>
                <ul>
                    <li>作用: 用户可以在输入框内输入内容</li>
                    <li>账号:
                        < input type="text" />
                    </li>
                </ul>
                <li>暗文输入框</li>
                <ul>
                    <li>作用: 用户可以在输入框内输入内容</li>
                    <li>密码:
                        < input type="password" />
                    </li>
                </ul>
                <li>给输入框设置默认值</li>
                <ul>
                    <li>账号:
                        < input type="text" value="123" />
                    </li>
                    <li>密码:
                        < input type="password" value="123" />
                    </li>
                </ul>
                <li>规定输入字段中的字符的最大长度</li>
                <ul>
                    <li>账号:
                        < input type="text" name="fullname" maxlength="8" />`</li>
                </ul>
                <li>单选框(radio)</li>
                <ul>
                    <li>作用: 用户只能从众多选项中选择其中一个</li>
                    <li>单选按钮，天生是不互斥的，如果想互斥，必须要有相同的name属性</li>
                </ul>
                <textarea>
                    <input type="radio" name="xingbie" /> 男
                    <input type="radio" name="xingbie" /> 女
                    <input type="radio" name="xingbie" /> 未知
                </textarea>
                <li>多选框(checkbox)</li>
                <ul>
                    <li>作用: 用户只能从众多选项中选择多个</li>
                    <li>复选框，最好也是有相同的name（虽然他不需要互斥，但是也要有相同的name）</li>
                </ul>
                <textarea>
                    <input type="checkbox" name="aihao"/> 篮球
                    <input type="checkbox" name="aihao"/> 足球
                     <input type="checkbox" name="aihao"/> 棒球
                </textarea>
                <li>给单选、多选设置默认值</li>
                <ul>
                    <li>指定radio和checkbox默认值, 前提是同一组内容必须设置相同name属性</li>
                </ul>
                <textarea>
                    <input type="radio" name="xingbie" checked="checked"/> 男
                    <input type="radio" name="xingbie" /> 女
                    <input type="radio" name="xingbie" /> 妖
                
                    <input type="checkbox" name="aihao" checked="checked"/> 篮球
                    <input type="checkbox" name="aihao" checked="checked"/> 足球
                    <input type="checkbox" name="aihao"/> 棒球
                </textarea>
                <li>label标签</li>
                <ul>
                    <li>作用: label标签不会向用户呈现任何特殊效果。不过，它为鼠标用户改进了可用性</li>
                    <li>注意:</li>
                    <ul>
                        <li>表单元素要有一个id，然后label标签就有一个for属性，for属性和id相同就表示绑定了</li>
                        <li>所有表单元素都可以通过label绑定</li>
                    </ul>
                </ul>
                <textarea>
                    <!--给文本框添加绑定-->
                    <label for="account">账号:</label>
                    <input type="text" id="account" />

                    <!--给单选框添加绑定-->
                    <input type="radio" name="sex" id="man" /> <label for="man">男</label>

                    <!--给多选框添加绑定-->
                    <input type="checkbox" id="basketball" />
                    <label for="basketball">篮球</label> 

                </textarea>
                <li>按钮</li>
                <ul>
                    <li>作用: 定义可点击按钮（多数情况下，用于通过 JavaScript 启动脚本）</li>
                    <li>
                        < input type="button" value="点我" />
                    </li>
                </ul>
                <li>图片按钮</li>
                <ul>
                    <li>作用:定义图像形式的提交按钮</li>
                    <li>
                        < input type="image" src="<div class=" "></div>.jpg" />
                    </li>
                </ul>
                <li>重置按钮</li>
                <ul>
                    <li>作用: 定义重置按钮。重置按钮会清除表单中的所有数据</li>
                    <li>
                        < input type="reset" />
                    </li>
                    <li>注意:</li>
                    <ul>
                        <li>这个按钮不需要写value自动就有“重置”文字</li>
                        <li>reset只对form表单中表单项有效果</li>
                    </ul>
                </ul>
                <li>提交按钮</li>
                <textarea>
                    - 作用:定义提交按钮。提交按钮会把表单数据发送到action属性指定的页面
                    - `<input type="submit" />`
                    -`注意事项:`
                    - 这个按钮不需要写value自动就有“提交”文字
                    - 要想通过submit提交数据到服务器, 被提交的表单项都必须设置name属性
                    - 默认明文传输(GET)不安全, 可以将method属性设置为POST改为非明文传输
                </textarea>
                <br />
                <li>隐藏域</li>
                <ul>
                    <li>作用: 定义隐藏的输入字段</li>
                    <li>
                        < input type="hidden">
                    </li>
                </ul>
                <li>取色器</li>
                <ul>
                    <li>-
                        < input type="color">
                    </li>
                </ul>
                <li>日期选择器</li>
                <ul>
                    <li><input type="date"></li>
                </ul>
            </ul>
        </div>
        <hr />
        <div class="header">
            <h2>数据列表</h2>
            <ul>
                <li>作用：给输入框绑定待选项</li>
                <li>格式：</li>
                <textarea>
                    <datalist>
                    <option>待选项内容</option>
                    </datalist>
                </textarea>
                <li>如何给输入框绑定待选列表 </li>
                <ul>
                    <li>搞一个输入框</li>
                    <li>搞一个datalist列表</li>
                    <li>给datalist列表标签添加一个id</li>
                    <li>给输入框添加一个list属性,将datalist的id对应的值赋值给list属性即可</li>
                </ul>
                <textarea>
                    请输入你的车型: <input type="text" list="cars">

                    <datalist id="cars">
                        <option>奔驰</option>
                        <option>宝马</option>
                        <option>奥迪</option>
                        <option>路虎</option>
                        <option>宾利</option>
                    </datalist>
                </textarea>
            </ul>
        </div>
        <hr />
        <div class="header">
            <h2>多行文本框</h2>
            <li>作用: textarea标签用于在表单中定义多行的文本输入控件</li>
            <ul>
                <li>cols属性表示columns“列”, 规定文本区内的可见宽度</li>
                <li>rows属性表示rows“行”, 规定文本区内的可见行数</li>
            </ul>
            <li>格式：
                < textarea cols="30" rows="10">默认
                    < /textarea>
            </li>
            <li>注意：</li>
            <ul>
                <li>可以通过cols和rows来指定输入框的宽度和高度</li>
                <li>默认情况下输入框是可以手动拉伸的</li>
            </ul>
            <textarea>
                        <!--禁止手动拉伸-->
                        <style type="text/css">
                            textarea{
                                resize: none;
                            }
                        </style>
            </textarea>
        </div>
        <hr />
        <div class="header">
            <h2>下拉列表</h2>
            <ul>
                <li>作用: select标签和ul、ol、dl一样，都是组标签. 用于创建表单中的待选列表, 可以从选择某一个带选项</li>
                <li>格式：</li>
                <textarea>
                    选择籍贯:
                    <select>
                        <option>北京</option>
                        <option>河北</option>
                        <option>河南</option>
                        <option>山东</option>
                        <option>山西</option>
                        <option>湖北</option>
                        <option>贵州</option>
                    </select>
                </textarea>
                <li>给下拉列表设置默认值</li>
                <ul>
                    <li>和radio、checkbox一样select也可以设置默认值, 通过selected属性设置</li>
                </ul>
                <textarea>
                    <select>
                        <option>北京</option>
                        <option>河北</option>
                        <option>河南</option>
                        <option>山东</option>
                        <option>山西</option>
                        <option>湖北</option>
                        <option selected="selected">贵州</option>
                    </select>
                </textarea>
                <li>给下拉列表添加分组</li>
                <textarea>
                    <select>
                        <optgroup label="北京市">
                            <option>海淀区</option>
                            <option>昌平区</option>
                            <option>朝阳区</option>
                        </optgroup>
                            <optgroup label="广州市">
                            <option>天河区</option>
                            <option>白云区</option>
                        </optgroup>
                        <option selected="selected">贵州</option>
                    </select>
                </textarea>
            </ul>
        </div>
        <hr />
        <div class="header">
            <h2>video</h2>
            <ul>
                <li>作用: 播放视频</li>
                <li>格式1:
                    < video src="">
                        < /video>
                </li>
                <li>video标签的属性</li>
                <textarea>
                - src: 告诉video标签需要播放的视频地址
                - autoplay: 告诉video标签是否需要自动播放视频
                - controls: 告诉video标签是否需要显示控制条
                - poster: 告诉video标签视频没有播放之前显示的占位图片
                - loop: 告诉video标签循环播放视频. 一般用于做广告视频
                - preload: 告诉video标签预加载视频, 但是需要注意preload和autoplay相冲, 如果设置了autoplay属性, 那么preload属性就会失效
                - muted:告诉video标签视频静音
                - width/height: 和img标签中的一模一样
            </textarea>
                <li>格式2</li>
                < video>
                    < source src="" type="">
                        < /source>
                            < source src="" type="">
                                < /source>
                                    < /video>
                                        <li>第二种格式存在的意义</li>
                                        <ul>
                                            <li>由于视频数据非常非常的重要, 所以五大浏览器厂商都不愿意支持别人的视频格式, 所以导致了没有一种视频格式是所有浏览器都支持的这个时候W3C为了解决这个问 题, 所以推出了第二个video标签的格式</li>
                                            <li>ideo标签的第二种格式存在的意义就是为了解决浏览器适配问题. video 元素支持 三种视频格式, 我们可以把这三种格式都通过source标签指定给video标签, 那么以 后当浏览器播放视频时它就会从这三种中选择一种自己支持的格式来播放
                                            </li>
                                        </ul>
                                        <li>注意：</li>
                                        <ul>
                                            <li>当前通过video标签的第二种格式虽然能够指定所有浏览器都支持的视频格式, 但 是想让所有浏览器都通过video标签播放视频还有一个前提条件, 就是浏览器必须支 持HTML5标签, 否则同样无法播放</li>
                                            <li>在过去的一些浏览器是不支持HTML5标签的, 所以为了让过去的一些浏览器也能够通过 video标签来播放视频, 那么我们以后可以通过一个JS的框架叫做html5media来实现</li>
                                        </ul>
            </ul>
            <h2>audio</h2>
            <ul>
                <li>作用：播放音频</li>
                <li>格式</li>

                <textarea>
                <audio src="">
                </audio>
                
                <audio>
                    <source src="" type="">
                </audio>
            </textarea>
                <li>注意点：</li>
            </ul>
            <ul>
                <li>audio标签的使用和video标签的使用基本一样, video中能够使用的属性在audio标签中 大部分都能够使用, 并且功能都一样. 只不过有3个属性不能用, height/width/poster</li>
            </ul>
            <h2>详细和概要标签</h2>
            <ul>
                <li>作用作用:利用summary标签来描述概要信息, 利用details标签来描述详情信息 默认情况下 是折叠展示, 想看见详情必须点击</li>
                <li>格式：</li>
                <textarea>
                    <details>
                        <summary>概要信息</summary>
                        详情信息
                    </details>
                </textarea>
            </ul>
        </div>
        <hr />
        <div class="header">
            <h2>marquee标签</h2>
            <ul>
                <li>作用：跑马灯效果</li>
                <li>格式：</li>
                <li>
                    < marquee>内容
                        < /marquee>
                </li>
                <li>属性：</li>
                <ul>
                    <li>direction: 设置滚动方向 left/right/up/down</li>
                    <li>scrollamount: 设置滚动速度, 值越大就越快</li>
                    <li>loop: 设置滚动次数, 默认是-1, 也就是无限滚动</li>
                    <li>behavior: 设置滚动类型 slide滚动到边界就停止, alternate滚动到边界就弹回</li>
                </ul>
                <li>注意：</li>
                <ul>
                    <li>marquee标签不是W3C推荐的标签, 在W3C官方文档中也无法查询这个标签, 但是各大浏览器对这个标签的支持非常好</li>
                </ul>
            </ul>
        </div>
        <hr />
        <div class="header">
            <h1>认识css</h1>
            <ul>
                <li>基本的css</li>

                <textarea>
                <h1 align="center">
                        <font face="微软雅黑" color="red">成功法则</font>
                    </h1>
                    <p align="center">
                        <font face="微软雅黑" color="blue" size="5">迟到毁一生</font>
                    </p>
                    <p align="center">
                        <font face="微软雅黑" color="blue" size="5">早退穷三代</font>
                    </p>
                    <p align="center">
                        <font face="微软雅黑" color="blue" size="5">按时上下班</font>
                    </p>
                    <p align="center">
                        <font face="微软雅黑" color="blue" size="5">必成高富帅</font>
                    </p>
            </textarea>
            </ul>
            <hr />
            <ul>
                <li>基本的html+css</li>

                <textarea>
                <style type="text/css">
                            h1{
                                text-align: center;
                                color: red;
                                font-family: "微软雅黑";
                            }
                            p{
                                text-align: center;
                                color: blue;
                                font-size: 20px;
                            }
                    </style>
                        
                    <h1>成功法则</h1>
                    <p>迟到毁一生</p>
                    <p>早退穷三代</p>
                    <p>按时上下班</p>
                    <p>必成高富帅</p>
            </textarea>
            </ul>
        </div>
        <hr />
        <div class="header">
            <ul>
                <li>格式：</li>

                <textarea>
                <style type="text/css">
                    标签名称{
                        属性名称: 属性对应的值;
                    }
                </style>
            </textarea>
            </ul>
            <ul>
                <li>注意：</li>
                <li>style标签必须写在head标签的开始标签和结束标签之间(也就是必须和title标签是兄弟关系)</li>
                <li>style标签中的type属性其实可以不用写, 默认就是type="text/css"</li>
                <li>设置样式时必须按照固定的格式来设置. key: value;其中:不能省略, 分号大多数情况下也不能省略(当有多个属性时, 最后一个可以省略)</li>
                <li>CSS的学习一共分为两大部分, 一个是CSS的属性, 另一个是CSS选择器.</li>
            </ul>
        </div>
        <hr />
        <div class="header">
            <h2>css常见属性</h2>
            <h3>文字属性</h3>
            <hr>
            <h4>font-style</h4>
            <ul>
                <li>作用：规定文字样式</li>
                <li>格式：font-style:italic</li>
                <li>取值：</li>
                <li>normal:正常的，默认就是正常的</li>
                <li>italic:倾斜的</li>
            </ul>
            <br>
            <h4>font-weight</h4>
            <ul>
                <li>作用：规定文字粗细</li>
                <li>格式：font-weight:bolder</li>
                <li>取值：</li>
                <li>单词取值：</li>
                <li>bold加粗</li>
                <li>bolder比加粗更粗</li>
                <li>lighter细线，默认就是细线</li>
                <li>数字取值：</li>
                <li>100~900之间的整百的数</li>
            </ul>
            <h4>font-family</h4>
            <ul>
                <li>作用：规定文字字体</li>
                <li>格式：font-family:楷体</li>
                <li>取值：各种字体名称</li>
                <li>注意：</li>
                <li>如果取值是中文，需要用双引号或者单引号括起来</li>
                <li>宋体 :SimSun, 黑体: SimHei, 微软雅黑 :Microsoft YaHei</li>
            </ul>
            <h4>font-variant</h4>
            <ul>
                <li>作用：设定小型大写字母</li>
                <li>格式：font-variant:small-caps</li>
            </ul>
            <h4>font-size</h4>
            <ul>
                <li>作用：设置文本的大小</li>
                <li>格式：font-size:16px</li>
                <li>注意：</li>
                <li>通过像素设置文本大小，可以对文本大小完全控制</li>
            </ul>
        </div>
        <hr />
        <div class="header">
            <h2>文本属性</h2>
            <h4>text-decoration</h4>
            <ul>
                <li>作用:给文本添加装饰</li>
                <li>格式：text-decoration:underline;</li>
                <li>取值：</li>
                <li>underline ：下划线</li>
                <li>line-through:删除下划线</li>
                <li>overline:上划线</li>
                <li>none：空，最常见的就是用于去掉超链接的下划线</li>
            </ul>
            <h4>text-align</h4>
            <ul>
                <li>作用：设置对其方式</li>
                <li>格式：text-align:center</li>
                <li>取值：</li>
                <li>left:左对齐</li>
                <li>right:右对齐</li>
                <li>center：居中对齐</li>
            </ul>
            <h4>text-indent</h4>
            <ul>
                <li>作用：设置文本缩进</li>
                <li>格式：text-indent:2em;</li>
                <li>取值：em,一个em代表一个文字的宽度</li>
            </ul>
            <h4>word-spacing</h4>
            <ul>
                <li>作用:可以改变字（单词）之间的间隔</li>
                <li>格式：word-indent:0px;</li>
                <li>取值：px,em</li>
            </ul>
            <h4>letter-spacing</h4>
            <ul>
                <li>作用：可以改变字母之间的间隔</li>
                <li>格式：letter-spacing:0px;</li>
                <li>取值：em,px</li>
            </ul>
            <h4>text-transform</h4>
            <ul>
                <li>作用：处理文本的大小写</li>
                <li>格式：text-transform:none</li>
                <li>取值：</li>
                <li>noone:空</li>
                <li>uppercase:全大写</li>
                <li>lowercase:全小写</li>
                <li>capitalizze:对每个单词的首字母大写</li>
            </ul>
            <h4>white-space</h4>
            <ul>
                <li>作用：处理文档中的空格，换行和TAB字符</li>
                <li>格式：white-space:normal;;</li>
                <li>取值：</li>
                <li>normal:清除，空格和换行TAB字符</li>
            </ul>
        </div>
        <hr />
        <div class="header">
            <h2>颜色属性</h2>
            <h4>color</h4>
            <ul>
                <li>作用：修改文字的颜色</li>
                <li>格式：color:rgb(0,0,0)</li>
                <li>取值：#数字，rgb(0,0,0)</li>
            </ul>
        </div>
        <hr />
        <div class="header">
            <h2>css选择器</h2>
            <h4>标签选择器</h4>
            <ul>
                <li>作用：根据指定的标签名称，在当前界面找到所有该名称的标签，然后设置属性</li>
                <li>格式：</li>
                <textarea>
                    标签名称{
                        属性:值;
                    }
                </textarea>
                <li>注意：</li>
                <li>标签选择器选中的是当前界面中所有的标签，而不能单独选中某一个标签</li>
            </ul>
            <h4>id选择器</h4>
            <ul>
                <li>作用：根据指定的id名称找到对应的标签，然后设置属性</li>
                <li>格式：</li>
                <textarea>
                    #id名称{
                        属性:值;
                    }
                </textarea>
                <li>注意：</li>
                <li>每个HTML标签都有一个属性叫做id, 也就是说每个标签都可以设置id</li>
                <li>在同一个界面中id的名称是不可以重复的</li>
                <li>在编写id选择器时一定要在id名称前面加上#</li>
                <li>id的名称是有一定的规范的</li>
                <li>id的名称只能由字母/数字/下划线(a-z 0-9 _)</li>
                <li>id名称不能以数字开头</li>
                <li>id名称不能是HTML标签的名称()不能是a h1 img input ...)</li>
            </ul>
            <h4>类选择器</h4>
            <ul>
                <li>作用：根据指定的类名称找到对应的标签，然后设置属性</li>
                <li>格式：</li>
                <textarea>
                    .类名{
                        属性:值;
                    }
                </textarea>
                <li>注意:</li>
                <li>每个HTML标签都有一个属性叫做class, 也就是说每个标签都可以设置类名</li>
                <li>在同一个界面中class的名称是可以重复的</li>
                <li>在编写class选择器时一定要在class名称前面加上点</li>
                <li>类名的命名规范和id名称的命名规范一样</li>
                <li>类名就是专门用来给CSS设置样式的</li>
                <li>在HTML中每个标签可以同时绑定多个类名</li>
                <textarea>
                    格式:
                    <标签名称 class="类名1 类名2 ...">
                    错误的写法:
                    <p class="para1" class="para2">
                </textarea>
            </ul>
            <h4>后代选择器</h4>
            <ul>
                <li>作用：找到指定标签的所有特定的后代标签，设置属性</li>
                <li>格式：</li>
                <textarea>
                    标签名称1 标签名称2{
                        属性:值;
                    }
                </textarea>
                <li>注意：</li>
                <li>后代选择器必须用空格隔开</li>
                <li>后代不仅仅是儿子, 也包括孙子/重孙子, 只要最终是放到指定标签中的都是后代</li>
                <li>后代选择器不仅仅可以使用标签名称, 还可以使用其它选择器</li>
                <li>后代选择器可以通过空格一直延续下去</li>
            </ul>
            <h4>子元素选择器</h4>
            <ul>
                <li>作用：找到指定标签中特定的直接子元素，然后设置属性</li>
                <li>格式：</li>
                <textarea>
                    标签名称1>标签名称2{
                        属性:值;
                    }
                </textarea>
                <li>注意：</li>
                <li>子元素选择器只会查找儿子, 不会查找其他被嵌套的标签</li>
                <li>子元素选择器之间需要用>符号连接, 并且不能有空格</li>
                <li>子元素选择器不仅仅可以使用标签名称, 还可以使用其它选择器</li>
                <li>子元素选择器可以通过>符号一直延续下去</li>
            </ul>
            <h4>交集选择器</h4>
            <ul>
                <li>作用：给所有选择器选中的标签中，相交的那部分标签设置属性</li>
                <li>格式：</li>

                <textarea>
                选择器1选择器2{
                    属性: 值;
                }
            </textarea>
            </ul>
            <ul>
                <li>注意：</li>
                <li>选择器和选择器之间没有任何的链接符号</li>
                <li>选择器可以使用标签名称/Id名称/class名称</li>
            </ul>
            <h4>并集选择器</h4>
            <ul>
                <li>作用：给所有选择器选中的标签设置属性</li>
                <li>格式：</li>

                <textarea>
                选择器1,选择器2{
                    属性:值;
                }
            </textarea>
            </ul>
            <ul>
                <li>注意：</li>
                <li>并集选择器必须使用,来连接</li>
                <li>选择器可以使用标签名称/id名称/class名称</li>
            </ul>
            <h3>兄弟选择器</h3>
            <h4>相邻兄弟选择器</h4>
            <ul>
                <li>作用：给指定选择器后面的所有选择器选中的所有标签设置属性</li>
                <li>格式：</li>

                <textarea>
                选择器1~选择器2{
                    属性:值;
                }
            </textarea>
            </ul>
            <ul>
                <li>注意：</li>
                <li>通用兄弟选择器必须需要用~连接</li>
                <li>通用兄弟选择器选中的是指定选择器后面某个选择器选中的所有标签, 无论有没有被隔开都可以选中</li>
            </ul>
            <h4>属性选择器</h4>
            <ul>
                <li>作用：根据指定的属性名称找到对应的标签，然后设置属性</li>
                <li>格式：</li>
                <li>[attribute]-作用：根据指定的属性名称找到对应的标签，然后设置属性</li>
                <li>[attribute-value]-作用：找到有指定的属性，并且属性的取值等于value 的标签，然后设置属性-最常见的应用场景就是区分imput属性
                </li>

                <textarea>
                input[type=password]{}
                <input type="text" name="" id="">
                <input type="password" name="" id="">
            </textarea>
            </ul>
            <h4>通配符选择器</h4>
            <ul>
                <li>作用：给当前界面上所有的标签设置属性</li>
                <li>格式：</li>

                <textarea>
                *{
                    属性:值;
                }
            </textarea>
            </ul>
            <ul>
                <li>注意：</li>
                <li>由于通配符选择器是设置界面上所有的标签的属性, 所以在设置之前会遍历所有的标签, 如果当前界面上的标签比较多, 那么性能就会比较差</li>
            </ul>
        </div>
        <hr />
        <div class="header">
            <h2>css三大特性</h2>
            <h4>继承性</h4>
            <ul>
                <li>作用：给父元素设置一些属性，子元素也可以使用</li>
                <li>示例代码：</li>

                <textarea>
                 <style>
                            div{
                                color: red;
                            }
                    </style>
                    <div>
                        <ul>
                            <li>
                                <p>我是段落</p>
                            </li>
                        </ul>
                    </div>
                    
                    <!--p会变成红色-->
            </textarea>
            </ul>
            <ul>
                <li>注意:</li>
                <li>并不是所有的属性都可以继 承, 只有以color/font-/text-/line-开头的属性才可以继承</li>
                <li>在CSS的继承中不仅仅是儿子可以继承, 只要是后代都可以继承</li>
                <li>继承性中的特殊性</li>
                <ul>
                    <li>a标签的文字颜色和下划线是不能继承的</li>
                    <li>h标签的文字大小是不能继承的</li>
                </ul>

                <textarea>
                <style>
                            div{
                                color: red;
                                text-decoration: none;
                                font-size: 30px;
                            }
                    </style>
                    <div>
                        <a href="#">我是超链接</a>
                    </div>
                    
                    <div>
                        <h1>我是大标题</h1>
                    </div>
                    <!--a的颜色和下划线不会发生变化, H的字体大小不对  -->
            </textarea>
            </ul>
            <ul>
                <li>应用场景：</li>
                <li>一般用于设置网页上的一些共性信息，列入 网页上的文字颜色，字体，文字的大小等内容
                </li>

                <textarea>
                body{
                    font-size: 30px;
                       font-family: "微软雅黑"
                       color: #666;
                 }
            </textarea>
            </ul>
            <h4>层叠性</h4>
            <ul>
                <li>作用:层叠行就是处理冲突的一种能力</li>
                <li>示例代码</li>

                <textarea>
                <style>
                            p{
                                color: red;
                            }
                            .para{
                                color: blue;
                            }
                    </style>
                    <p id="identity" class="para">我是段落</p>
                    
                    <!-- 最终显示蓝色, 因为红色被覆盖掉了 -->
            </textarea>
            </ul>
            <ul>
                <li>注意:</li>
                <li>层叠性只有在多个选择器选中"同一个标签", 然后又设 置了"相同的属性", 才会发生层叠性</li>
            </ul>
            <h4>优先级</h4>
            <ul>
                <li>作用：当多个选择器选中同一个标签，并且给同一个标签设置相同的属性时，如何 层叠就由优先级来确定
                </li>
                <li>优先级判断的三种方式</li>
                <li>间接选中就是指继承</li>
                <li>如果是间接选中，那么就是谁离目标标签比较近就听谁的</li>

                <textarea>
                    <style>
                        li{
                                   color: blue;
                             }
                            ul{
                                   color: red;
                             }
                       </style>
                       <ul>
                           <li>
                               <p id="identity" class="para">我是段落</p>
                           </li>
                       </ul>
                       <!-- 最终显示蓝色 -->
                </textarea>
            </ul>
            <ul>
                <li>相同选择器（直接选中）</li>
                <li>如果都是直接选中，并且都是同类型的选择器，那么谁写在后面就听谁的</li>

                <textarea>
                    <style>
                        p{
                                   color: blue;
                             }
                           p{
                                   color: red;
                             }
                       </style>
                       <ul>
                           <li>
                               <p id="identity" class="para">我是段落</p>
                           </li>
                       </ul>
                       <!-- 最终显示红色 -->
                </textarea>
            </ul>
            <ul>
                <li>不同选择器</li>
                <li>如果都是直接选中，并且不是相同类型的选择器，那么就会按照选择器的优先级来层叠</li>
                <li>id>类>标签>通配符>继承>浏览器默认</li>

                <textarea>
                    <style>
                        #identity{
                                  color: purple;
                              }
                              .para{
                                  color: pink;
                              }
                              p{
                                  color: green;
                              }
                              *{
                                  color: blue;
                              }
                              li{
                                  color: red;
                              }
                      </style>
                      <ul>
                          <li>
                              <p id="identity" class="para">我是段落</p>
                          </li>
                      </ul>
                      <!-- 最终显示紫色 -->
                </textarea>
            </ul>
            <h4>优先级权重</h4>
            <ul>
                <li>作用：当多个选择器混合在一起使用时</li>
                <li>权重的计算规则</li>
                <li>首先先计算计算学选择器中有多少个id，id多的选择器优先级最高</li>
                <li>如果id的个数一样, 那么再看类名的个数, 类名个数多的优先级最高</li>
                <li>如果类名的个数一样, 那么再看标签名称的个数, 标签名称个数多的优先级最高</li>
                <li>如果id个数一样, 类名个数也一样, 标签名称个数也一样, 那么就不会继续往下计算了, 那么此时谁写在后面听谁的</li>
                <li>示例代码：</li>

                <textarea>
                    <style>
                        #identity1 .box2{
                                 color: red;
                             }
                             .box1 .box2{
                                 color: green;
                             }
                             div ul li p{
                                 color: blue;
                             }
                     </style>
                     <div id="identity1" class="box1">
                         <ul>
                             <li>
                                 <p id="identity2" class="box2">我是段落</p>
                             </li>
                         </ul>
                     </div>
                     <!-- id多最终显示红色 -->
                </textarea>
                <textarea>
                    <style>
                        .box1 .box2{
                                  color: blue;
                              }
                              div .box2{
                                  color: green;
                              }
                      </style>
                      <div id="identity1" class="box1">
                          <ul>
                              <li>
                                  <p id="identity2" class="box2">我是段落</p>
                              </li>
                          </ul>
                      </div>
                      <!-- id一样, 比类多, 最终显示蓝色 -->
                </textarea>
                <textarea>
                    <style>
                        #identity1 ul li p{
                                  color: red;
                              }
                              #identity1 ul p{
                                  color: green;
                              }
                      </style>
                      <div id="identity1" class="box1">
                          <ul>
                              <li>
                                  <p id="identity2" class="box2">我是段落</p>
                              </li>
                          </ul>
                      </div>
                      <!-- id一样, 类一样, 比标签多最终显示红色 -->
                </textarea>
                <textarea>
                    <style>
                        .box1 li #identity2{
                                  color: blue;
                              }
                      
                              #identity1 ul .box2{
                                  color: red;
                              }
                      </style>
                      <div id="identity1" class="box1">
                          <ul>
                              <li>
                                  <p id="identity2" class="box2">我是段落</p>
                              </li>
                          </ul>
                      </div>
                      <!-- id一样, 类一样, 标签一样, 最终显示红色 -->
                </textarea>

                <li>注意：</li>
                <li>只有选择器时直接选中标签的才需要计算权重，否则一定会听直接选中的选择器的</li>
                <h4>###!important</h4>
                <li>作用：用于提升某个直接选中标签的选择器中的某属性的 优先级的，可以将被指定的属性的优先级提升为最高
                </li>
                <li>示例代码</li>
                <textarea>
                    <style>
                                #identity{
                                    color: purple;
                                    font-size: 50px;
                                }
                                .para{
                                    color: pink ;
                                }
                                p{
                                    color: green !important;
                                }
                        </style>
                        <ul>
                            <li>
                                <p id="identity" class="para">我是段落</p>
                            </li>
                        </ul>
                        <!-- 最终显示绿色 -->
                </textarea>
                <li>注意点:</li>
                <ul>

                    <li> !important只能用于直接选中, 不能用于间接选中</li>

                    <li>通配符选择器选中的标签也是直接选中的</li>

                    <li>!important只能提升被指定的属性的优先级, 其它的属性的优先级不会被提升</li>

                    <li>!important必须写在属性值得分号前面</li>

                    <li>!important前面的感叹号不能省略</li>
                </ul>
            </ul>
            </ul>
            <hr />
        </div>
        <div class="header">
            <H4>div标签</H4>
            <ul>
                <li>作用：一般用于配合css完成网页的基本布局</li>
                <textarea>
                <style>
                            .header{
                                width: 980px;
                                height: 100px;
                                background: red;
                                margin: auto;
                                margin-bottom: 10px;
                            }
                            .content{
                                width: 980px;
                                height: 500px;
                                background: green;
                                margin: auto;
                                margin-bottom: 10px;
                            }
                            .footer{
                                width: 980px;
                                height: 100px;
                                background: blue;
                                margin: auto;
                            }
                            .logo{
                                width: 200px;
                                height: 50px;
                                background: pink;
                                float: left;
                                margin: 20px;
                            }
                            .nav{
                                width: 600px;
                                height: 50px;
                                background: yellow;
                                float: right;
                                margin: 20px;
                            }
                            .aside{
                                width: 250px;
                                height: 460px;
                                background: purple;
                                float: left;
                                margin: 20px;
                            }
                            .article{
                                width: 650px;
                                height: 460px;
                                background: deepskyblue;
                                float: right;
                                margin: 20px;
                    }
                    </style>
                    <div class="header">
                            <div class="logo"></div>
                            <div class="nav"></div>
                        </div>
                        <div class="content">
                            <div class="aside"></div>
                            <div class="article"></div>
                        </div>
                        <div class="footer"></div>
            </textarea>
            </ul>
            <h4>span</h4>
            <ul>
                <li>作用：一般用于配合css修改网页中的一些局部信息</li>
                <textarea>
                    <style>
                        span{
                            color: red;
                        }
                </style>
                <p>努力到<span>无能为力</span>, 拼搏到<span>感动自己</span></p>
                </textarea>
                <li>div会单独的占领一行,而span不会单独占领一行</li>
                <li>div是一个容器级的标签, 而span是一个文本级的标签</li>
                <li>容器级的标签中可以嵌套其它所有的标签</li>
                <li>常见容器级的标签: div h ul ol dl li dt dd </li>
                <li>文本级的标签中只能嵌套文字/图片/超链接</li>
                <li>常见文本级的标签:span p buis strong em ins del </li>
            </ul>
        </div>
        <hr />
        <div class="header">
            <h2>css元素显示模式转换</h2>
            <ul>
                <li>设置元素display的属性</li>
                <li>displayd的取值</li>
                <li>block 块级，inline 行内，inline行内块级元素</li>
            </ul>
        </div>
        <hr />
        <div class="header">
            <h2>盒模型</h2>
            <hr />
            <h4>边框属性</h4>
            <ul>
                <li>边框就是围绕在标签宽度和高度周围的线条</li>
                <li>边框属性的格式</li>
                <li>连写 （同时设置四条边，遵从上右下左的顺序）</li>
                <li>border：边框的宽度，边框的样式，边框的颜色</li>
                <li>示例代码</li>
                <textarea>
                    <style>
                                .box{
                                    width: 100px;
                                    height: 100px;
                                    background-color: red;
                                    border: 5px solid blue;
                                    /*border: 5px solid;*/
                                    /*border: 5px blue;*/
                                    /*border: solid blue;*/
                                }
                        </style>
                </textarea>
                <li>注意：</li>
                <li>连写格式中样式不能省略，连写之后就看不到边框</li>
                <li>连写格式中宽度可以省略，省略之后还是可以看到边框</li>
                <li>连写示例代码</li>
                <textarea>
                    <style>
                                .box{
                                    width: 100px;
                                    height: 100px;
                                    background-color: red;
                                    border-top:5px solid blue;
                                    border-right:10px dashed green;
                                    border-bottom:15px dotted purple;
                                    border-left:20px double pink;
                                }
                        </style>
                </textarea>
                <li>按要素连写：</li>
                <li>border-width：上右下左；</li>
                <li>border-style：上右下左；</li>
                <li>border-color：上右下左</li>
                <li>示例代码：</li>
                <textarea>
                    <style>
                                .box{
                                    width: 500px;
                                    height: 500px;
                                    background-color: red;
                                    border-width: 5px 10px 15px 20px;
                                    border-style: solid dashed dotted double;
                                    border-color: blue green purple pink;
                                    /*border-color: blue green purple;*/
                                    /*border-color: blue green;*/
                                    /*border-color: blue;*/
                                }
                        </style>
                </textarea>
                <li>注意：</li>
                <li>这三个属性的取值是按照顺时针来赋值的</li>
                <li>这三个属性的取值省略时的规律：</li>
                <li>上 右 下 左 > 上 右 下 > 左边的取值和右边的一样</li>
                <li>上 右 下 左 > 上 右 > 左边的取值和右边的一样 下边的取值和上边一样</li>
                <li>上 右 下 左 > 上 > 右下左边取值和上边一样</li>
                <li>非连写（方向+要素）： border-top-width: ; -  border-top-style:; -  border-top-color:; -  border-right-width:; -  border-right-style:; -  border-right-color:; -  border-bottom-width:; -  border-bottom-style: ; -  border-bottom-color:; -  border-left-width:;
                    -  border-left-style:; -  border-left-color:;</li>
                <li>示例代码：</li>
                <textarea>
                    <style>
                                .box{
                                    width: 500px;
                                    height: 500px;
                                    background-color: red;
                        
                                    border-top-width: 5px;
                                    border-top-style: solid;
                                    border-top-color: blue;
                        
                                    border-right-width: 10px;
                                    border-right-style: dashed;
                                    border-right-color: green;
                        
                                    border-bottom-width: 15px;
                                    border-bottom-style: dotted;
                                    border-bottom-color: purple;
                        
                                    border-left-width: 20px;
                                    border-left-style: double;
                                    border-left-color: pink;
                                }
                        </style>
                </textarea>
                <li>注意：同一个选择器如果设置了多个边框属性，后面的会覆盖前面的</li>
                <textarea>
                    .box3{
                                    border: 5px solid red;
                                    border-right:5px dashed red;
                        }   
                         内边距属性
                        - 什么是内边距?
                        边框和内容之间的距离就是内边距
                        
                        - 格式
                        - 单独设置四条边
                         - padding-top: ;
                         - padding-right: ;
                         - padding-bottom: ;
                         - padding-left: ;
                        - 示例代码
                        <style>
                                div{
                                    width: 98px;
                                    height: 90px;
                                    border: 1px solid #000;
                                    background-color: red;
                                }
                                .box1{
                                    padding-top: 20px;
                                    padding-right:40px;
                                    padding-bottom:80px;
                                    padding-left:160px;
                               }
                        </style>
                </textarea>
                <li>勇士设置四条边</li>
                <li>padding:上右下左；</li>
                <li>示例代码：</li>
                <textarea>
                    <style>
                                div{
                                    width: 98px;
                                    height: 90px;
                                    border: 1px solid #000;
                                    background-color: red;
                                }
                                .box1{
                                    /*padding:20px 40px 80px 160px;*/
                                    /*padding:20px 40px 80px;*/
                                    /*padding:20px 40px;*/
                                    padding:20px;
                                }
                        </style>
                </textarea>
                <li>注意：</li>
                <li>给标签设置内边距之后, 标签占有的宽度和高度会发生变化</li>
                <li>给标签设置内边距之后, 内边距也会有背景颜色</li>
            </ul>
            <h4>外边距属性</h4>
            <ul>
                <li>标签和标签之间的距离就是外边距</li>
                <li>格式：</li>
                <li>单独设置四条边：margin-top: ;margin-right: ;margin-bottom: ; margin-left: ;</li>
                <li>示例代码：</li>
                <textarea>
                    <style>
                        .box1{
                                  margin-top:20px;
                                  margin-right:40px;
                                  margin-bottom:80px;
                                  margin-left:160px;
                              }
                      </style>
                </textarea>
                <li>同时设置四条边</li>
                <li>margin:上右下左；</li>
                <li>示例代码：</li>
                <textarea>
                    <style>
                        .box1{
                                  margin:20px 40px 80px 160px;
                                  /*margin:20px 40px 80px;*/
                                  /*margin:20px 40px;*/
                                  /*margin:20px;*/
                              }
                      </style>
                </textarea>
                <li>外边距的那部分是没有颜色的</li>
                <li>外边距合并现象</li>
                <li>默认布局的垂直方向上边距是不会重叠的，会出现合并现象，谁的外边距大就听谁的</li>
                <li>示例代码：</li>
                <textarea>

                            span{
                               display: inline-block;
                                width: 100px;
                                height: 100px;
                                border: 1px solid #000;
                            }
                            div{
                                height: 100px;
                                border: 1px solid #000;
                            }
                            .hezi1{
                                margin-right:50px;
                            }
                            .hezi2{
                                margin-left:100px;
                            }
                            .box1{
                                margin-bottom:50px;
                            }
                            .box2{
                                margin-top:100px;
                            }
                </textarea>
                <li>margin-top问题</li>
                <li>如果两个盒子是嵌套关系, 那么设置了里面一个盒子顶部的外边距, 外面一个盒子也会被顶下来</li>
                <li>如果外面的盒子不想被一起定下来,那么可以给外面的盒子添加一个边框属性</li>
                <li>在企业开发中, 一般情况下如果需要控制嵌套关系盒子之间的距离, 应该 首先考虑padding, 其次再考虑margin(margin本质上是用于控制兄弟关系之间的间隙的)</li>
                <li>示例代码</li>
                <textarea>

                                .big{
                                    width: 500px;
                                    height: 500px;
                                    background-color: red;
                                    /*不设置边框, big也会被small的顶部外边距顶下去*/
                                    border: 5px solid #000;
                                }
                                .small{
                                    width: 200px;
                                    height: 200px;
                                    background-color: blue;
                                    margin-top:150px;
                                    margin-left:150px;
                                }
                </textarea>
                <li>text-align:center;和margin:0 auto;区别</li>
                <li>text-align: center; 是设置盒子中存储的文字/图片水平居中</li>
                <li>margin:0 auto;是让盒子自己水平居中</li>
                <li>示例代码</li>
                <textarea>
                    <!DOCTYPE html>
                    <html lang="en">
                    <head>
                        <meta charset="UTF-8">
                        <title>53-盒子居中和内容居中</title>
                        
                            .father{
                                width: 800px;
                                height: 500px;
                                background-color: red;
                                /*文字图片会居中*/
                                /*text-align: center;*/
                                /*盒子自身会居中*/
                                margin:0 auto;
                            }
                            .son{
                                width: 100px;
                                height: 100px;
                                background-color: blue;
                            }
                    </head>
                    <body>
                    <div class="father">
                        我是文字<br/>
                        ![](images/girl.jpg)
                        <div class="son"></div>
                    </div>
                    </body>
                    </html>
                </textarea>
            </ul>
            <h4>盒模型</h4>
            <ul>
                <li>CSS盒模型仅仅是一个形象的比喻, HTML中的标签都是盒模型</li>
                <li>CSS盒模型指那些可以设置宽度高度/内边距/边框/外边距的标签</li>
                <li>这些属性我们可以用日常生活中的常见事物——盒子作一个比喻来 理解，所以HTML标签又叫做盒模型
                </li>
                <li>示例代码：</li>
                <textarea>
                    <!DOCTYPE html>
                <html lang="en">
                <head>
                    <meta charset="UTF-8">
                    <title>48-CSS盒子模型</title>
                    
                        span,a,b,strong{
                            display: inline-block;
                            width: 100px;
                            height: 100px;
                            border: 6px solid #000;
                            padding: 20px;
                            margin: 20px;
                        }

                    
                </head>
                <body>

                <span>我是span</span>
                <a href="#">我是超链接</a>
                <b>我是加粗</b>
                <strong>我是强调</strong>

                </body>
                </html>
                </textarea>
                <li>盒模型宽度和高度</li>
                <li>内容的宽度和高度</li>
                <li>就是通过width/height属性设置的宽度和高度</li>
                <li>元素的宽度和高度</li>
                <li>宽度 = 左边框 + 左内边距 + width + 右内边距 + 右边框</li>
                <li>高度 同理可证</li>
                <li>规律</li>
                <li>增加了padding/border之后元素的宽高也会发生变化 - 如果增加了padding/border之后还想保持元素的宽高, 那么就必须减去内容的宽高</li>
                <li>元素空间的宽度和高度</li>
                <li>宽度 = 左外边距 + 左边框 + 左内边距 + width + 右内边距 + 右边框 + 右外边距</li>
                <li>高度 同理可证</li>
            </ul>
            <h4>box-sizing属性</h4>
            <ul>
                <li>box-sizing取值</li>
                <li>content-box:</li>
                <li>元素的宽高 = 边框 + 内边距 + 内容宽高</li>
                <li>border-box:</li>
                <li>元素的宽高 = width/height的宽高</li>
                <li>增加padding和border之后要想保证盒子元素的宽高不变, 系统会自动减去一部分内容的宽度和高度
                </li>
                <li>示例代码:</li>
                <textarea>
                    <!--增加padding/border之后元素宽高会变大-->
                <style>
                    .box1{
                        width: 200px;
                        height: 200px;
                        background-color: blue;
                        float: right;
                        border: 20px solid #000;
                        padding: 20px;
                    }
                    </style>
                    
                    <!--增加padding/border之后元素宽不会变大-->
                    <style>
                    .box1{
                    box-sizing: border-box;
                        width: 200px;
                        height: 200px;
                        background-color: blue;
                        float: right;
                        border: 20px solid #000;
                        padding: 20px;
                    }
                    </style>
                </textarea>
            </ul>
        </div>
        <div class="header">
            <h2>浮动</h2>
            <h4>网页的布局方式</h4>
            <ul>
                <li>网页的布局方式其实就是指浏览器如何对网页中的元素进行排版的</li>
                <li>标准流(文档流/普通流)排版方式</li>
                <ul>
                    <li>其实浏览器默认的排版方式就是标准流的排版方式</li>
                    <li>在CSS中将元素分为三类, 分别是块级元素/行内元素/行内块级元素</li>
                    <li>在标准流中有两种排版方式, 一种是垂直排版, 一种是水平排版</li>
                    <ul>
                        <li>垂直排版, 如果元素是块级元素, 那么就会垂直排版</li>
                        <li>水平排版, 如果元素是行内元素/行内块级元素, 那么就会水平排版</li>
                    </ul>
                </ul>
                <li>浮动流排版方式</li>
                <ul>
                    <li>浮动流是一种"半脱离标准流"的排版方式</li>
                    <li>浮动流只有一种排版方式, 就是水平排版. 它只能设置某个元素左对齐或者右对齐</li>
                </ul>
                <li>注意点：</li>
                <ul>
                    <li>浮动流中没有居中对齐, 也就是没有center这个取值</li>
                    <li>在浮动流中是不可以使用margin: 0 auto;</li>
                </ul>
                <li>特点：</li>
                <ul>
                    <li>在浮动流中是不区分块级元素/行内元素/行内块级元素的</li>
                    <li>无论是块级元素/行内元素/行内块级元素都可以水平排版</li>
                    <li>在浮动流中无论是块级元素/行内元素/行内块级元素都可以设置宽高</li>
                    <li>浮动流中的元素和标准流中的行内块级元素很像</li>
                </ul>
            </ul>
            <h4>浮动元素的脱标</h4>
            <ul>
                <li>脱标：脱离标准流</li>
                <li>当某一个元素浮动之后, 那么这个元素看上去 就像被从标准流中删除了一样, 这个就是浮动元素的脱标</li>
                <li>如果前面一个元素浮动了, 而后面一个元素 没有浮动 , 那么这个时候前面一个元就会盖住后面一个元素</li>
            </ul>
            <h4>浮动元素排序规则</h4>
            <ul>
                <li>浮动元素排序规则</li>
                <li>相同方向上的浮动元素, 先浮动的元素会显示在前面, 后浮动的元素会显示在后面</li>
                <li>不同方向上的浮动元素, 左浮动会找左浮动, 右浮动会找右浮动</li>
                <li>浮动元素浮动之后的位置, 由浮动元素浮动之前在标准流中的位置来确定</li>
            </ul>
            <h4>浮动元素字围现象</h4>
            <ul>
                <li>浮动元素不会挡住没有浮动元素中的文字, 没有浮动的文字会自 动给浮动的元素让位置,这个就是浮动元素字围现象
                </li>
                <textarea>
                    div{
                        float: left;
                        width: 100px;
                        height: 100px;
                        /*background-color: red;*/
                        border: 1px solid #000;
                    }
                    p{
                        width: 500px;
                        height: 500px;
                        background-color: yellow;
                    }
                </textarea>
                <li>应用场景：图文混排</li>
            </ul>
        </div>
        <hr />
        <div class="header">
            <h2>清除浮动</h2>
            <h4>盒子高度问题</h4>
            <ul>
                <li>在标准流中内容的高度可以撑起盒子的高度</li>
                <textarea>
                    <style>

                        div{
                            background-color: red;
                        }
                
                        p{
                            width: 200px;
                            height: 100px;
                            background-color: blue;
                        }
                        
                </style>
                    
                <div>
                    <p></p>
                </div>
                </textarea>
                <li>在浮动流中浮动元素内容的高不可以撑起盒子的高</li>
                <textarea>
                    <style>

                        div{
                            background-color: red;
                        }
                
                        p{
                            float: left;
                            width: 200px;
                            height: 100px;
                            background-color: blue;
                        }
                        
                </style>
                    
                <div>
                    <p></p>
                </div>
                </textarea>
            </ul>
            <h4>清除浮动方式1：</h4>
            <ul>
                <li>给前面的父盒子添加高度</li>
                <li>示例代码：</li>
                <textarea>
                    <style>
                        *{
                            margin: 0;
                            padding: 0;
                        }
                        .box1{
                            background-color: red;
                            /*这里*/
                            height: 50px;
                        }
                        .box2{
                            background-color: purple;
                        }
                        ul{
                            list-style: none;
                        }
                        .ul01 li{
                            background-color: blue;
                        }
                        .ul02 li{
                            background-color: green;
                        }
                        ul li{
                            float: left;
                        }
                    </style>
                    
                    <div class="box1">
                        <ul class="ul01">
                            <li>大娃</li>
                            <li>二娃</li>
                            <li>三娃</li>
                        </ul>
                    </div>
                    <div class="box2">
                        <ul class="ul02">
                            <li>李南江</li>
                            <li>极客江南</li>
                            <li>江哥</li>
                        </ul>
                    </div>
                </textarea>
                <li>注意：这种方式不常用</li>
            </ul>
            <h4>清除浮动方式2：</h4>
            <ul>
                <li>利用clear:both;属性清除前面浮动元素对我的影响</li>
                <li>示例代码:</li>
                <textarea>
                    <style>
                        *{
                            margin: 0;
                            padding: 0;
                        }
                        .box1{
                            background-color: red;
                        }
                        .box2{
                            background-color: purple;
                            /*这里*/
                            clear: both;
                            /*margin无效*/
                            margin-top: 30px;
                        }
                        ul{
                            list-style: none;
                        }
                        .ul01 li{
                            background-color: blue;
                        }
                        .ul02 li{
                            background-color: green;
                        }
                        ul li{
                            float: left;
                        }
                </style>
                
                <div class="box1">
                    <ul class="ul01">
                        <li>大娃</li>
                        <li>二娃</li>
                        <li>三娃</li>
                    </ul>
                </div>
                <div class="box2">
                    <ul class="ul02">
                        <li>李南江</li>
                        <li>极客江南</li>
                        <li>江哥</li>
                    </ul>
                </div>
                </textarea>
                <li>注意 ：使用clear:both之后margin属性会失效,不常用</li>
            </ul>
            <h4>清除浮动方式3：</h4>
            <ul>
                <li>在两个有浮动子元素的盒子之间添加一个额外的块级元素</li>
                <li>示例代码：</li>
                <textarea>
                    <style>
                        *{
                            margin: 0;
                            padding: 0;
                        }
                        .box1{
                            background-color: red;
                        }
                        .box2{
                            background-color: purple;
                        }
                        ul{
                            list-style: none;
                        }
                        .ul01 li{
                            background-color: blue;
                        }
                        .ul02 li{
                            background-color: green;
                        }
                        ul li{
                            float: left;
                        }
                        /*这里*/
                        .wall{
                            clear: both;
                        }
                        .h20{
                            /*利用额外块级元素实现margin*/
                            height: 20px;
                            background-color: deepskyblue;
                        }
                </style>
                    
                <div class="box1">
                    <ul class="ul01">
                        <li>大娃</li>
                        <li>二娃</li>
                        <li>三娃</li>
                    </ul>
                </div>
                
                <!--这里-->
                <div class="wall h20"></div>
                
                <div class="box2">
                    <ul class="ul02">
                        <li>李南江</li>
                        <li>极客江南</li>
                        <li>江哥</li>
                    </ul>
                </div>
                </textarea>
                <li>注意：在外墙法中可以通过设置额外标签的高度来实现margin效果 ，需要添加大量无意义的标签，不常用
                </li>
            </ul>
            <h4>清除浮动的方式4：</h4>
            <ul>
                <li>在前面一个盒子的最后添加一个额外的块级元素</li>
                <li>示例代码</li>
                <textarea>
                    <style>
                        *{
                            margin: 0;
                            padding: 0;
                        }
                        .box1{
                            background-color: red;
                        }
                        .box2{
                            background-color: purple;
                            /*margin有效*/
                            margin-top: 20px;
                        }
                        ul{
                            list-style: none;
                        }
                        .ul01 li{
                            background-color: blue;
                        }
                        .ul02 li{
                            background-color: green;
                        }
                        ul li{
                            float: left;
                        }
                        /*这里*/
                        .wall{
                            clear: both;
                        }
                </style>
                    
                <div class="box1">
                    <ul class="ul01">
                        <li>大娃</li>
                        <li>二娃</li>
                        <li>三娃</li>
                    </ul>
                    <!--这里-->
                    <div class="wall"></div>
                </div>
                
                <div class="box2">
                    <ul class="ul02">
                        <li>李南江</li>
                        <li>极客江南</li>
                        <li>江哥</li>
                    </ul>
                </div>
                </textarea>
                <li>注意:内墙法会自动撑起盒子的高度, 所以可以直接设置margin属性, 和内墙法一样需要添加很多无意义的空标签，有违结构与表现的分离， 在后期维护中将是噩梦
                </li>

                <h4>清除浮动方式5：</h4>
                <li>overflow:hidden的作用是清除溢出盒子边框外的内容</li>
                <li>示例代码</li>
                <textarea>
                    .test{
                        width: 100px;
                        height: 100px;
                        border: 1px solid #000;
                        background-color: red;
                        overflow: hidden;
            }
                    
            <div class="test">我是文字我是文字我是文字我是文字我是文字我是文字
                我是文字我是文字我是文字我是文字我是文字我是文字我是文字</div>
                </textarea>
                <li>如何利用overflow:hidden;清除浮动:给前面一个盒子添加overflow:hidden属性</li>
                <li>示例代码：</li>
                <textarea>
                    <style>
                        *{
                            margin: 0;
                            padding: 0;
                        }
                        .box1{
                            background-color: red;
                            /*这里*/
                            overflow: hidden;
                            *zoom:1;
                        }
                        .box2{
                            background-color: purple;
                            /*margin有效*/
                            margin-top: 20px;
                        }
                        ul{
                            list-style: none;
                        }
                        .ul01 li{
                            background-color: blue;
                        }
                        .ul02 li{
                            background-color: green;
                        }
                        ul li{
                            float: left;
                        }
                </style>
                    
                <div class="box1">
                    <ul class="ul01">
                        <li>大娃</li>
                        <li>二娃</li>
                        <li>三娃</li>
                    </ul>
                </div>
                <div class="box2">
                    <ul class="ul02">
                        <li>李南江</li>
                        <li>极客江南</li>
                        <li>江哥</li>
                    </ul>
                </div>
                </textarea>
                <li>注意:优点可以不用添加额外的标签又可以撑起父元素的高度, 缺点和定位结合在一起使用时会有冲突
                </li>
            </ul>
            <h4>清除浮动方式6：</h4>
            <ul>
                <li>给前面的盒子添加伪元素来清除浮动</li>
                <li>示例代码</li>
                <textarea>
                        <style>
                            *{
                                margin: 0;
                                padding: 0;
                            }
                            .box1{
                                background-color: red;
                            }
                            .box2{
                                background-color: purple;
                                /*margin有效*/
                                margin-top: 20px;
                            }
                            ul{
                                list-style: none;
                            }
                            .ul01 li{
                                background-color: blue;
                            }
                            .ul02 li{
                                background-color: green;
                            }
                            li{
                                float: left;
                            }
                            
                            /*这里*/
                            .clearfix:after {
                                /*生成内容作为最后一个元素*/
                                content: "";
                                /*使生成的元素以块级元素显示,占满剩余空间*/
                                display: block;
                                /*避免生成内容破坏原有布局的高度*/
                                height: 0;
                                /*使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互*/
                                visibility: hidden;
                                /*重点是这一句*/
                                clear: both;
                            }
                            .clearfix {
                                /*用于兼容IE, 触发IE hasLayout*/
                                *zoom:1;
                            }
                    </style>
                    <div class="box1 clearfix">
                        <ul class="ul01">
                            <li>大娃</li>
                            <li>二娃</li>
                            <li>三娃</li>
                        </ul>
                    </div>
                    <div class="box2">
                        <ul class="ul02">
                            <li>李南江</li>
                            <li>极客江南</li>
                            <li>江哥</li>
                        </ul>
                    </div>
                    </textarea>
                <li>注意：</li>
                <ul>
                    <li>本质上和内墙法一样, 都是在前面一个盒子的最后添加一个额外的块级元素</li>
                    <li>添加伪元素后可以撑起盒子的高度, 所以可以直接设置margin属性</li>
                    <li>CSS中还有一个东西叫做伪类, 伪元素和伪类不是同一个东西</li>
                </ul>
                <h4>清除浮动方式7：</h4>
                <ul>
                    <li>给前面的盒子添加双伪元素来清除浮动</li>
                    <li>示例代码:</li>
                    <textarea>
                            <style>
                                *{
                                    margin: 0;
                                    padding: 0;
                                }
                                .box1{
                                    background-color: red;
                                }
                                .box2{
                                    background-color: purple;
                                    /*margin有效*/
                                    margin-top: 20px;
                                }
                                ul{
                                    list-style: none;
                                }
                                .ul01 li{
                                    background-color: blue;
                                }
                                .ul02 li{
                                    background-color: green;
                                }
                                li{
                                    float: left;
                                }
                                
                                /*这里*/
                                .cf:before,.cf:after {
                                    content:"";
                                    display:table;
                                    /*重点是这一句*/
                                    clear:both;
                                }
                                .cf {
                                    zoom:1;
                                }
                        </style>
                        <div class="box1 clearfix">
                            <ul class="ul01">
                                <li>大娃</li>
                                <li>二娃</li>
                                <li>三娃</li>
                            </ul>
                        </div>
                        <div class="box2">
                            <ul class="ul02">
                                <li>李南江</li>
                                <li>极客江南</li>
                                <li>江哥</li>
                            </ul>
                        </div>
                        </textarea>
                    <li>注意：</li>
                    <ul>
                        <li>添加伪元素后可以撑起盒子的高度, 所以可以直接设置margin属性</li>
                    </ul>
                </ul>
            </ul>
        </div>
        <hr />
        <div class="header">
            <h2>定位</h2>
            <hr />
            <h4>相对定位</h4>
            <ul>
                <li>相对定位就是相对于自己以前在标准流中的位置来移动</li>
                <li>格式：position: relative;</li>
                <li>相对定位注意：在相对定位中同一个方向上的定位属性只能使用一个<br /> top/bottom 只能用一个<br /> left/right 只能用一个<br /> 相对定位是不脱离标准流的, 会继续在标准流中占用一份空间<br /> 由于相对定位是不脱离标准流的, 所以在相对定位中区分块级元素/行内元素/行内块级元素<br /> 由于相对定位是不脱离标准流的, 并且相对定位的元素会占用标准流中的位置, 所以当给相对定位的元素设置margin/padding等属性的时会影响到标准流的布局。</li>
                <li></li>
            </ul>
            <h4>绝对定位</h4>
            <ul>
                <li>绝对定位就是相对于body或者某个定位流中的祖先元素来定位</li>
                <li>position: absolute;</li>
                <li>绝对定位注意点:<br /> 绝对定位的元素是脱离标准流的, 不会占用标准流中的位置<br /> 由于绝对定位的元素是脱离标准流的, 所以绝对定位的元素不区分块级元素/行内元素/行内块级元素<br /> 如果一个绝对定位的元素是以body作为参考点, 那么其实是以网页首屏的宽度和高度作为参考点, 而不是以整个网页的宽度和高度作为参考点<br /> 相对于body定位会随着页面的滚动而滚动
                    <br /> 一个绝对定位的元素会忽略祖先元素的padding
                </li>
                <li>绝对定位参考点:<br /> 默认情况下所有的绝对定位的元素, 无论有没有祖先元素, 都会以body作为参考点<br /> 如果一个绝对定位的元素有祖先元素, 并且祖先元素中有一个是定位流中的元素, <br /> 那么这个绝对定位的元素就会以定位流的那个祖先元素作为参考点
                    <br /> 如果一个绝对定位的元素有祖先元素, 并且祖先元素中有多个是定位流中的元素, <br /> 那么这个绝对定位的元素会以离它最近的那个定位流的祖先元素为参考点。
                </li>
                <li>绝对定位水平居中：<br /> 1.注意当一个盒子绝对定位之后不能使用margin: 0 auto;让盒子自身居中<br /> 2.如果想让过一个绝对定位的盒子自身居中, 可以使用left: 50%; margin-left:-元素宽度一半px;</li>
            </ul>
            <h4>固定定位</h4>
            <ul>
                <li>固定定位可以让某个盒子不随着滚动条的滚动而滚动</li>
                <li>格式:position: fixed;</li>
                <li>固定定位注意点:<br /> 固定定位的元素是脱离标准流的, 不会占用标准流中的位置<br /> 由于固定定位的元素是脱离标准流的, 所以绝对定位的元素不区分块级元素/行内元素/行内块级元素</li>
                <li>固定定位应用场景:</li>
                <ul>
                    <li>网页对联广告</li>
                    <li>网页头部通栏(穿透效果)</li>
                </ul>
            </ul>
            <h4> 静态定位</h4>
            <ul>
                <li>默认情况下标准流中的元素position属性就等于static, 所以静态定位其实就是默认的标准流</li>
                <li>静态定位应用场景:一般用于配合JS清除定位属性</li>
            </ul>
            <h4>z-index属性</h4>
            <ul>
                <li>作用：用于指定定位的元素的覆盖关系</li>
                <li>定位元素的覆盖关系：默认情况下定位的元素一定会盖住没有定位的元素<br /> 默认情况下写在后面的定位元素会盖住前面的定位元素
                    <br /> 默认情况下所有元素的z-index值都是0, 如果设置了元素的z-index值, 那么谁比较大谁就显示在前面</li>
                <li>定位元素的从父现象：<br /> 父元素没有z-index值, 那么子元素谁的z-index大谁盖住谁<br /> 父元素z-index值不一样, 那么父元素谁的z-index大谁盖住谁
                </li>
                <li>应用场景：控制界面上的定位元素的覆盖关系, 例如网页中后面的定位元素不能覆盖前面的导航条通栏</li>
            </ul>
        </div>
        <hr />
        <div class="header">
            <h1>认识JaveScript</h1>
        </div>
        <div class="header">
            <h2>Javascript 语言核心</h2>
            <ul>
                <li>核心是针对文本、数组、日期和正则表达式的操作定义了很少的api，但是这个api不<br /> 包括输入输出功能。输入和输出功能（类似网络、存储和图形相关的复杂特性）是由Jav ascript
                    <br />所属的宿主环境提供的</li>
            </ul>
            <h4>引入js</h4>
            <ul>
                <li>内部镶嵌：在
                    < head>
                        < /head>之中</li>
                <li>外部引入：在
                    < body>
                        < /body>之中</li>
            </ul>
            <h4>基本结构</h4>
            <ul>
                <li>结构、样式、行为相分离，通常会采用外部引用。结构用HTML，行为用js，样式用css</li>
            </ul>
            <h2>js基本语法</h2>
            <h4>标识符规则</h4>
            <hr />
            <p>在应用程序中，使用变量来作为值的符号名。变量的名字又叫做标识符，其需要遵守一定的规则</p>
            <ul>
                <li>必须以字母、下划线（_）或者美元符号（$）开头</li>
                <li>后续的字符也可以是数字（0-9）</li>
                <li>因为 JavaScript 语言是区分大小写的，所以字母可以是从“A”到“Z”的大写字母和从“a”到“z”的小写字母。</li>
                <li>可以使用大部分 ISO 8859-1 或 Unicode 编码的字符作标识符，例如 å 和 ü。你也可以使用 Unicode 转义字符 作标识符。</li>
            </ul>
            <h4>声明变量</h4>
            <hr />
            <ul>
                <li>使用关键词 var 。例如 var x=4。这个语法可以用来声明局部变量和全局变量。</li>
                <li>使用关键词 let 。例如 let y=13。这个语法可以用来声明块作用域的局部变量。</li>
            </ul>
            <h4>变量求值</h4>
            <ul>
                <p>用 var 或 let 语句声明的变量，如果没有赋初始值，则其值为 undefined 。</p>
            </ul>
            <h4>block区块</h4>
            <ul>
                <li>作用：把代码包在一块</li>
                <textarea>
                    {
                        let a=1
                        let b=2
                    }
                </textarea>
                <li>常与if/for/while合用</li>
            </ul>
            <h4>if else语句</h4>
            <ul>
                <li>if (表达式) {语句 1} else {语句 2}</li>
                <li>注意：{}在在语句只有一句的时候可以省略，但不建议省略。</li>
                <li>写法：</li>
                <textarea>
                    if (表达式) {
                        语句
                    } else if (表达式) {
                        语句
                    } else {
                        语句
                    }
                </textarea>
                <textarea>
                    function fn() {
                        if (表达式) {
                            return 表达式
                        }
                        if (表达式) {
                            return 表达式
                        }
                        return 表达式
                    }
                </textarea>
            </ul>
            <h4>swith语句</h4>
            <ul>
                <textarea>
                swith(fruit){
                    case "banana":
                    //..
                    break;
                    case "apple":
                    //...
                    break;
                    default:
                    break;
                    }
                }
            </textarea>
            </ul>
            <h4>while语句</h4>
            <ul>
                <p>while (表达式) {语句}</p>
                <p>判断真假：</p>
                <ul>
                    <li>表达式为真，执行，执行完再判断真假</li>
                    <li>表达式为假，执行后面的。</li>
                </ul>
                <p>死循环：</p>
                <textarea>
                var a=0.1                     //初始化
                while(!a==1){              //判断
                    console.log(a)         //循环体
                    a=+0.1              //增长
                    }
                }
            </textarea>
            </ul>
            <h4>for循环</h4>
            <ul>
                <p>是while循环的简单写法</p>
                <textarea>
                    for (语句1; 表达式2; 语句3) {  //初始化并判断
                        循环体                      //增长
                    }
                </textarea>
                <li>执行顺序为： 语句1--表达式2--循环体--语句。如果表达式2不成立，直接跳出循环</li>
            </ul>
            <h4>break</h4>
            <p>退出当前所有循环</p>
            <h4>continue</h4>
            <p>退出一次聚集他最近那次循环</p>
            <h4>label</h4>
            <p>指代码块</p>
            <ul>
                <textarea>
                    {
                        foo: 1;
                    }
                </textarea>
                <li>浏览器会打印{foo:1}</li>
            </ul>
        </div>
        <hr />
        <div class="header">
            <h2>js对象</h2>
            <h4>创建对象</h4>
            <ul>
                <li>创建对象有两种对象：1，声明形式；2，构造形式</li>
                <textarea>
                    //声明形式
                    let obj = {
                        a:2,
                        ...
                    }
                    //构造形式
                    let obj = new Object();
                    obj.a = 2;
                </textarea>
                <li>对象字面量</li>
                <textarea>
                    let person = {
                        name: 'Luna',
                        age: '18',
                        hobby: 'reading',
                        greeting: function() {
                            console.log('hello,I am ' + this.name)
                        }
                    };
                </textarea>
                <li>使用new表达式</li>
                <textarea>
                    let person = new Object();
                    person.name = 'Luna';
                    person.age = '18';
                    person.hobby = 'reading';
                    person.greeting = function () {
                        console.log('hello,I am ' + this.name)
                    }
                </textarea>
                <li>使用构造函数</li>
                <textarea>
                    function Person(name, age, hobby) {
                        this.name = name;
                        this.age = age;
                        this.hobby = hobby;
                        this.greeting = function () {
                        console.log('hello,I am ' + this.name)
                        }
                    }
                    let person = new Person('Luna','18','reading');。
                </textarea>
            </ul>
            <h4>对象文本和属性</h4>
            <ul>
                <li>创建对象时，可以可以初始化对象的一些属性：</li>
                <textarea>
                    let user = {
                    name : 'leo',
                  age  : 18
                }
                </textarea>
                <li>然后可以对该对象进行属性对增删改查操作：</li>
                <textarea>
                    // 增加属性
                    user.addr = "China";
                    // user => {name: "leo", age: 18, addr: "China"}

                    // 删除属性
                    delete user.addr
                    // user => {name: "leo", age: 18}

                    // 修改属性
                    user.age  = 20;
                    // user => {name: "leo", age: 20}

                    // 查找属性
                    user.age;
                    // 20
                </textarea>
            </ul>
            <h4>symbol</h4>
            <ul>
                <li>Symbol 值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种 类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属 性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产 生冲突
                </li>
                <li>作为属性名，每一个Symbol值都是不相等的。</li>
                <textarea>// 无参数
                    let a = Symbol();
                    let b = Symbol();
                    a === b //false
                    
                    // 有参数
                    let c = Symbol('foo');
                    let d = Symbol('foo');
                    c === c //false
                </textarea>
                <li>Symbol 值作为对象属性名时，不能用点运算符。</li>
                <li>在对象内部，使用Symbol定义属性时，Symbol值必须放在方括号[]内。</li>
            </ul>
            <h4>对象的属性</h4>
            <ul>
                <li>for...in 循环：该方法依次访问一个对象及其原型链中所有可枚举的属性（不含 Symbol 属性）。</li>
                <li>Object.keys(obj)：该方法返回一个对象 obj 自身包含（不包括原型中）的所有属性的名称的数组。</li>
                <li>Object.getOwnPropertyNames(obj)：该方法返回一个数组，它包含了对象 obj 所有拥有的属性（无论是否可枚举）的名称。</li>
                <li>Object.getOwnPropertySymbols(obj)：返回一个数组，包含对象自身的所有 Symbol 属性的键名。</li>
                <li>Reflect.ownKeys(obj)：Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</li>
            </ul>
            <h2>计算属性</h2>
            <ul>
                <li>创造对象时，可以在对象字面量中使用方括号，即计算属性：</li>
                <textarea>
                    let key = "name";
                    let inputKey = prompt("请输入key", "age");
                    let user = {
                        [key] : "leo",
                    [inputKey] : 18
                    }
                    // 当用户在 prompt 上输入 "age" 时，user 变成下面样子：
                    // {name: "leo", age: 18}
                </textarea>
                <li>计算属性也可以时表达式</li>
                <textarea>
                    let key = "name";
                    let user = {
                        ["my_" + key] : "leo"
                    }
                    user["my_" + key]; // "leo"
                </textarea>
            </ul>
            <h2>对象属性存在性检测</h2>
            <hr />
            <h4>使用in关键字</h4>
            <ul>
                <li>该方法可以判断对象的自由属性和继承来的属性是否存在</li>
                <textarea>
                    let user = {name: "leo"};
                    "name" in user;            //true，自有属性存在
                    "age"  in user;            //false
                    "toString" in user;     //true，是一个继承属性
                </textarea>
            </ul>
            <h4>使用对象的hasOwnProPerty()方法</h4>
            <ul>
                <li>该方法只能判断自有属性是否存在，对于继承属性会返回 false 。</li>
                <textarea>
                    let user = {name: "leo"};
                    user.hasOwnProperty("name");       //true，自有属性中有 name
                    user.hasOwnProperty("age");        //false，自有属性中不存在 age
                    user.hasOwnProperty("toString");   //false，这是一个继承属性，但不是自有属性
                </textarea>
            </ul>
            <h4>用undefinrd判断</h4>
            <ul>
                <li>该方法可以判断对象的自由属性和继承属性</li>
                <textarea>
                    let user = {name: "leo"};
                    user.name !== undefined;        // true
                    user.age  !== undefined;        // false
                    user.toString !== undefined     // true
                </textarea>
                <li>该方法存在一个问题，如果属性的值就是unfefined的话，该方法不能返回想要的结果：</li>>
                <textarea>
                    let user = {name: undefined};
                    user.name !== undefined;        // false，属性存在，但值是undefined
                    user.age  !== undefined;        // false
                    user.toString !== undefined;    // true
                </textarea>
                <h4>在条件语句中直接判断</h4>
                <ul>
                    <textarea>
                        let user = {};
                        if(user.name) user.name = "pingan";
                        //如果 name 是 undefine, null, false, " ", 0 或 NaN,它将保持不变

                        user; // {}
                    </textarea>
                </ul>
            </ul>
        </div>
        <div class="header">
            <h2>对象循环遍历</h2>
            <ul>
                <li>当我们需要对象中每个属性，可以使用for。。in语句来实现</li>
            </ul>
            <h2>for...in循环</h2>
            <ul>
                <li>for...in 语句以任意顺序遍历一个对象的除 Symbol 以外的可枚举属性</li>
                <textarea>
                    let user = {
                        name : "leo",
                      age  : 18
                    }
                    
                    for(let k in user){
                        console.log(k, user[k]);
                    }
                    // name leo
                    // age 18
                </textarea>
            </ul>
        </div>
        <hr />
        <div class="header">
            <h2>对象拷贝</h2>
            <hr />
            <h4>赋值操作</h4>
            <ul>
                <li>基本类型</li>
                <p>概念：基本类型值在内存中占据固定大小，保存在栈内存中（不包含闭包中的变量）。 常见包括：undefined,null,Boolean,String,Number,Symbol
                </p>
                <li>引用类型</li>
                <p>概念：引用类型的值是对象，保存在堆内存中。而栈内存存储的是对象的变量标识符以及对象在堆内存中的存储地址(引用)，引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。 常见包括：Object,Array,Date,Function,RegExp等。
                </p>
            </ul>
            <h4>基本数据类型赋值</h4>
            <ul>
                <li>在栈内存中的数据发生数据变化的时候， 系统会自动为新的变量分配一个新的之值在栈内存中，两个变量相互独立，互不影响的。
                </li>
                <textarea>
                        let user  = "leo";
                        let user1 = user;
                        user1 = "pingan";
                        console.log(user);  // "leo"
                        console.log(user1); // "pingan"
                    </textarea>
            </ul>
            <h4>引用数据类型赋值</h4>
            <ul>
                <li>在 JavaScript 中，变量不存储对象本身，而是存储其“内存中的地址”，换 句话说就是存储对其的“引用”。 如下面 leo 变量只是保存对user 对象对应引用：</li>
                <li>let user = { name: "leo", age: 18};<br /> let leo = user;</li>
                <li>其他变量也可以引用 user 对象：</li>
                <li>let leo1 = user;<br /> let leo2 = user;</li>
                <li>但是由于变量保存的是引用，所以当我们修改变量 leo \ leo1 \ leo2 这 些值时，也会改动到引用对象 user ，但当 user 修改，则其他引用该对象的变量，值都会发生变化：</li>
                <textarea>
                            leo.name = "pingan";
                            console.log(leo);   // {name: "pingan", age: 18}
                            console.log(leo1);  // {name: "pingan", age: 18}
                            console.log(leo2);  // {name: "pingan", age: 18}
                            console.log(user);  // {name: "pingan", age: 18}

                            user.name = "pingan8787";
                            console.log(leo);   // {name: "pingan8787", age: 18}
                            console.log(leo1);  // {name: "pingan8787", age: 18}
                            console.log(leo2);  // {name: "pingan8787", age: 18}
                            console.log(user);  // {name: "pingan8787", age: 18}
                    </textarea>
            </ul>
        </div>
        <div class="header">
            <h2>浅拷贝</h2>
            <hr />
            <h4>概念</h4>
            <ul>
                <li>概念：新的对象复制已有对象中非对象属性的值和对象属性的引用。也 可以理解为：一个新的
                    <br />对象直接拷贝已存在的对象的对象属性的引用，即 浅拷贝。
                </li>
                <li>浅拷贝只对第一层属性进行了拷贝，当第一层的属性值是基本数据类型时，新的对象和原<br /> 对象互不影响，但是如果第一层的属性值是复杂数据类型，那么新对象和原对象的属性值其指向 的是同一块内存地址。
                </li>
            </ul>
            <h4>实现浅拷贝</h4>
            <h5>Obeject.assign()</h5>
            <ul>
                <li>语法： Object.assign(target, ...sources) ES6中拷贝对象的方法，接受的第一个参数是拷贝的目标target，剩下的参数是拷贝的源对象sources（可以是多个）。</li>
                <textarea>
                        // 示例1 对象浅拷贝
                        let user = { name: "leo", skill: { JavaScript: 90, CSS: 80}};
                        let leo = Object.assign({}, user);
                        leo.name = "leo1";
                        leo.skill.CSS = 90;
                        console.log(leo.name);      // "leo1" ⚠️ 差异！
                        console.log(user.name);     // "leo"  ⚠️ 差异  ！
                        console.log(leo.skill.CSS); // 90
                        console.log(user.skill.CSS);// 90
                    </textarea>
                <li>结果看出浅拷贝只是在跟属性（对象的第一层级）创建了一个新的对象，但是对于属性的值<br /> 是对象的话指挥拷贝一份相同的内存地址
                </li>
                <li>object.assign(使用注意）：</li>
                <ul>
                    <li>只拷贝源对象的自身属性（不拷贝继承属性）</li>
                    <li>不会拷贝对象不可枚举对象的属性</li>
                    <li>属性名为Symbol,可以被Object.assign拷贝</li>
                    <li>undefined和null无法转成对象，它们不能作为Object.assign参数，但是可以作为源对象</li>
                </ul>
                <textarea>
                        Object.assign(undefined); // 报错
                        Object.assign(null);      // 报错

                        Object.assign({}, undefined); // {}
                        Object.assign({}, null);      // {}

                        let user = {name: "leo"};
                        Object.assign(user, undefined) === user; // true
                        Object.assign(user, null)      === user; // true
                    </textarea>
            </ul>
            <h4>Array.prototype.slice()</h4>
            <ul>
                <li>语法： arr.slice([begin[, end]]) slice() 方法返回一个新的数组对象，这一对象是一个由 begin 和 end 决定的原数组的浅拷贝（包括 begin，不包括end）</li>
                <textarea>
                        // 示例 数组深拷贝
                        let user = ["leo", "pingan", {name: "pingan8787"}];
                        let leo  = Array.prototype.slice.call(user);
                        leo[0] = "pingan888";
                        leo[2]["name"] = "pingan999";
                        console.log(leo[0]);          // "pingan888"  ⚠️ 差异！
                        console.log(user[0]);         // "leo"        ⚠️ 差异！
                        console.log(leo[2]["name"]);  // "pingan999"
                        console.log(user[2]["name"]); // "pingan999"
                    </textarea>
            </ul>
            <h4>Array.prototype.concent()</h4>
            <ul>
                <li>语法： var new_array = old_array.concat(value1[, value2[, ...[, valueN]]]) concat() 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组</li>
                <textarea>
                        let user  = [{name: "leo"},   {age: 18}];
                        let user1 = [{age: 20},{addr: "fujian"}];
                        let user2 = user.concat(user1);
                        user1[0]["age"] = 25;
                        console.log(user);  // [{"name":"leo"},{"age":18}]
                        console.log(user1); // [{"age":25},{"addr":"fujian"}]
                        console.log(user2); // [{"name":"leo"},{"age":18},{"age":25},{"addr":"fujian"}]
                    </textarea>
                <li>Array.prototype.concat 也是一个浅拷贝，只是在根属性(对象的第一层级)创建了一个新的对象，但是对于属性的值是对象的话只会拷贝一份相同的内存地址。</li>
            </ul>
            <h4>手写浅拷贝</h4>
            <ul>
                <li>实现原理：新的对象复制已有对象中非对象属性的值和对象属性的引用,也就是说对象属性并不复制到内存。</li>
                <textarea>
                        function cloneShallow(source) {
                            let target = {};
                            for (let key in source) {
                                if (Object.prototype.hasOwnProperty.call(source, key)) {
                                    target[key] = source[key];
                                }
                            }
                            return target;
                        }
                    </textarea>
                <li>for in</li>
                <li>for...in语句可以任意顺序遍历一个对象自由的，继承，可枚举的，非Symbol的属性。 对于不同的属性，语句都会被执行。 </li>
                <li>hasOwnProperty</li>
                <li>该函数返回值为布尔值，所有继承了 Object 的对象都会继承到 hasOwnProperty 方法，和 in 运算符不同，该函数会忽略掉那些从原型链上继承到的属性和自身属性。<br /> 语法：obj.hasOwnProperty(prop)
                    <br /> prop 是要检测的属性字符串名称或者Symbol。</li>
            </ul>
            <h4>拓展运算符</h4>
            <ul>
                <li>语法： var cloneObj = { ...obj }; 扩展运算符也是浅拷贝，对于值是对象的属性无法完全拷贝成2个不同对象，但是如果属性都是基本类型的值的话，使用扩展运算符也是优势方便的地方。</li>
                <textarea>
                        let user = { name: "leo", skill: { JavaScript: 90, CSS: 80}};
                        let leo = {...user};
                        leo.name = "leo1";
                        leo.skill.CSS = 90;
                        console.log(leo.name);      // "leo1" ⚠️ 差异！
                        console.log(user.name);     // "leo"  ⚠️ 差异！
                        console.log(leo.skill.CSS); // 90
                        console.log(user.skill.CSS);// 90
                    </textarea>
            </ul>
            <h2>深拷贝</h2>
            <ul>
                <li>概念：复制变量值，对于引用数据，则递归至基本类型后，再复制。深拷贝后的对象与原来的对象完全隔离，互不影响，对一个对象的修改并不会影响另一个对象。</li>

            </ul>
            <h4>实现深拷贝</h4>
            <ul>
                <P> JSON.parse(JSON.stringify())</P>
                <li>其原理是把一个对象序列化成为一个JSON字符串，将对象的内容转换成字符串的形式再保存在磁盘上，再用JSON.parse() 反序列化将JSON字符串变成一个新的对象。</li>
                <textarea>
                        let user = { name: "leo", skill: { JavaScript: 90, CSS: 80}};
                        let leo = JSON.parse(JSON.stringify(user));
                        leo.name = "leo1";
                        leo.skill.CSS = 90;
                        console.log(leo.name);      // "leo1" ⚠️ 差异！
                        console.log(user.name);     // "leo"  ⚠️ 差异！
                        console.log(leo.skill.CSS); // 90 ⚠️ 差异！
                        console.log(user.skill.CSS);// 80 ⚠️ 差异！
                    </textarea>
                <p>JSON.stringify()使用注意：</p>
                <li>拷贝的对象的值中如果有函数，undefined,symbol则经过JSON.string()序列化的JSON字符串中这个键值会消失；</li>
                <li>无法拷贝不可枚举的属性，无法拷贝对象的原型链</li>
                <li>拷贝Date引用类型会变成字符串</li>
                <li>拷贝RegExp引用类型会变成空对象</li>
                <li>对象中含有NaN，Infinity和-Infinity,则序列化的结果会变成null</li>
                <li>无法拷贝对象的循环应用（即obj[key]=obj)</li>
            </ul>
            <h2>手写深拷贝</h2>
            <ul>
                <li>核心思想是递归，遍历对象，数组知道里面都是最基本数据类型，然后再去赋值，就是深度拷贝。实现代码：</li>
                <textarea>
                        const isObject = obj => typeof obj === 'object' && obj != null;

                        function cloneDeep(source) {
                            if (!isObject(source)) return source; // 非对象返回自身
                            const target = Array.isArray(source) ? [] : {};
                            for(var key in source) {
                                if (Object.prototype.hasOwnProperty.call(source, key)) {
                                    if (isObject(source[key])) {
                                        target[key] = cloneDeep(source[key]); // 注意这里
                                    } else {
                                        target[key] = source[key];
                                    }
                                 }
                            }
                             return target;
                         }
                    </textarea>

            </ul>
        </div>
        <hr/>
        <div class="header">
            <h2>Object对象</h2>
            <h4>Object的实例方法</h4>
            <ul>
                <p>Object实例对象的方法，主要有六个：</p>
                <li>Object.prototype.valueOf()：返回当前对象对应的值</li>
                <li>Object.prototype.toString():返回当前对象对应的字符串形式</li>
                <li>Object.prototype.toLocaleString():返回当前对象对应的本地字符串形式
                    <li>
                        <li>Object.prototype.hasOwnProperty():判断某个属性是否为当前对象的自身属性， 还是继承自原型对象的属性
                        </li>
                        <li>Object.prototypr.isPrototypeOf:判断当前对象是否为另一个对象的原型</li>
                        <li>Object.prototype.proertyIsEnumerable:判断某个属性是否可枚举</li>
            </ul>
        </div>
        <hr>
        <div class="header">
            <h2>Math对象</h2>
            <h4>Math的静态属性和方法</h4>
            <ul>
                <p>Math对象的静态属性，提供以下一些数学常数。</p>
                <li>Math.E：常数e。</li>
                <li>Math.LN2：2 的自然对数。</li>
                <li>Math.LN10：10 的自然对数</li>
                <li>Math.LOG2E：以 2 为底的e的对数。</li>
                <li>Math.LOG10E：以 10 为底的e的对数。</li>
                <li>Math.PI：常数π。</li>
                <li>Math.SQRT1_2：0.5 的平方根。</li>
                <li>Math.SQRT2：2 的平方根。</li>
                <p>Math对象提供一下一些静态方法</p>
                <li>Math.abs()：绝对值</li>
                <li>Math.ceil()：向上取整</li>
                <li>Math.floor()：向下取整</li>
                <li>Math.max()：最大值</li>
                <li>Math.min()：最小值</li>
                <li>Math.pow()：幂运算</li>
                <li>Math.sqrt()：平方根</li>
                <li>Math.log()：自然对数</li>
                <li>Math.exp()：e的指数</li>
                <li>Math.round()：四舍五入</li>
                <li>Math.random()：随机数</li>
            </ul>
        </div>
        <div class="header">
            <h1>DOM</h1>
            <ul>
                <li>querySelector() 方法返回文档中匹配指定 CSS 选择器的一个元素。</li>
                <li>preventDefault() 方法,将通知 Web 浏览器不要执行与事件关联的默认动作（如果存在这样的动作）。例如，如果 type 属性是 "submit"，在事件传播的任意阶段可以调用任意的事件句柄，通过调用该方法，可以阻止提交表单。注 意，如果 Event 对象的 cancelable 属性是 fasle，那么就没有默认动作，或者不能阻止默 认动作。无论哪种情况，调用该方法都没有作用。
                </li>
                <li>addEventListener() 方法用于向指定元素添加事件句柄</li>
                <li>localStorage.getItem(key):获取指定key本地存储的值</li>
                <li>localStorage.setItem(key,value)：将value存储到key字段</li>
                <li>querySelectorAll() 方法返回文档中匹配指定 CSS 选择器的所有元素，返回 NodeList 对象。</li>
                <li>map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</li>
                <li>indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。</li>
                <li>JSON.stringify() 方法用于将 JavaScript 值转换为 JSON 字符串。</li>
                <li>JSON.parse() 方法用于将一个 JSON 字符串转换为对象。</li>
                <li>classList() 属性返回元素的类名，作为 DOMTokenList 对象。 该属性用于在元素中添加，移除及切换 CSS 类。 classList 属性是只读的，但你可以使用 add() 和 remove() 方法修改它。</li>
                <li>selectedIndex 属性可设置或返回下拉列表中被选选项的索引号。</li>
                <li> click() 方法触发 click 事件，或规定当发生 click 事件时运行的函数。 当鼠标指针停留在元素上方，然后按下并松开鼠标左键时，就会发生一次 click
                </li>
                <li>change() 函数触发 change 事件，或规定当发生 change 事件时运行的函数。将函数绑定到 change 事件,规定当被选元素的 change 事件发生时运行的函数。</li>
                <li>forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数。</li>
                <li>contains方法用来查看dom元素的包含关系</li>
                <li>toggle() 方法切换元素的可见状态。</li>
                <li>target 事件属性可返回事件的目标节点（触发该事件的节点），如生成事件的元素、文档或窗口。</li>
                <li>duration 属性返回当前音频/视频的长度，以秒计。</li>
                <li>currentTime 属性设置或返回音频/视频播放的当前位置（以秒计）</li>
                <li>then()方法是异步执行。 意思是：就是当.then()前的方法执行完后再执行then()内部的程序，这样就避免了，<br /> 数据没获取到等的问题。 语法：promise.then(onCompleted, onRejected);
                </li>
                <li>
                    < aside> 标签定义其所处内容之外的内容。 aside 的内容应该与附近的内容相关。
                        < aside> 的内容可用作文章的侧栏
                </li>
                <li>remove() 方法移除被选元素，包括所有的文本和子节点。</li>
                <li>add() 方法将元素添加到匹配元素的集合中。</li>
                <li>.contains() 方法用于判断指定元素内是否包含另一个元素。即判断另一个DOM元素是否是指定DOM元素的后代。</li>
                <li>currentTime 属性设置或返回视频播放的当前位置（以秒计）</li>
                <li>duration 属性返回当前音频/视频的长度，以秒计。</li>
                <li>async 函数中可能会有 await 表达式，async 函数执行时，如果遇到 await 就会先暂停执行 ，等到触发的异步操作完成后，恢复 async 函数的执行并返回解析值。</li>
                <li>appendChild() 方法向节点添加最后一个子节点。</li>
                <li>setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式。</li>
                <li>indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。</li>
                <li>当用户滚动指定的元素时，会发生 scroll 事件。 scroll 事件适用于所有可滚动的元素和 window 对象（浏览器窗口）。 scroll() 方法触发 scroll 事件，或规定当发生 scroll 事件时运行的函数。</li>
                <li>trimStart()和trimEnd()这两个方法。它们的行为与trim()一致，trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。</li>
                <li>String.prototype.match 调用 RegExp.prototype[Symbol.match] String.prototype.replace 调用 RegExp.prototype[Symbol.replace] String.prototype.search 调用 RegExp.prototype[Symbol.search] String.prototype.split 调用 RegExp.prototype[Symbol.split]</li>
                <li>Math.trunc方法用于去除一个数的小数部分，返回整数部分。</li>
                <li>Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。</li>
                <li>Math.cbrt()方法用于计算一个数的立方根。</li>
                <li>Math.imul方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。</li>
                <li>Math.hypot方法返回所有参数的平方和的平方根。</li>
                <li>focus() 方法触发 focus 事件，或规定当发生 focus 事件时运行的函数。</li>
                <li>setItem() 作为 Storage 接口的方法，接受一个键名和值作为参数，将会把键名添加到存储中，如果键名已存在，则更新其对应的值。</li>
                <li>在SpeechSynthesisUtterance该界面的Web Speech API的代表发言请求。它包含语音服务应阅读的内容以及有关如何阅读的信息（例如语言，音调和音量）。</li>
                <li>createElement() 方法通过指定名称创建一个元素</li>
                <li>reload()方法用于刷新当前文档。 reload() 方法类似于你浏览器上的刷新页面按钮。</li>
                <li>push() pop() shift() unshift() splice() sort() reverse() 你可以打开控制台，然后对前面例子的 items 数组尝试调用变更方法。比如 example1.items.push({ message: 'Baz' })。</li>
                <li>getAttribute() 方法返回指定属性名的属性值。</li>
                <li>closest() 方法获得匹配选择器的第一个祖先元素，从当前元素开始沿 DOM 树向上。</li>
                <li>setAttribute() 方法添加指定的属性，并为其赋指定的值。</li>
                <li>reload() 方法用于重新加载当前文档。</li>
                <textarea>
                                    <!-- 阻止单击事件继续传播 -->
                <a v-on:click.stop="doThis"></a>

                <!-- 提交事件不再重载页面 -->
                <form v-on:submit.prevent="onSubmit"></form>

                <!-- 修饰符可以串联 -->
                <a v-on:click.stop.prevent="doThat"></a>

                <!-- 只有修饰符 -->
                <form v-on:submit.prevent></form>

                <!-- 添加事件监听器时使用事件捕获模式 -->
                <!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 -->
                <div v-on:click.capture="doThis">...</div>

                <!-- 只当在 event.target 是当前元素自身时触发处理函数 -->
                <!-- 即事件不是从内部元素触发的 -->
                <div v-on:click.self="doThat">...</div>
                </textarea>
                <li>v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。<br> v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。

                    <br> v-enter-to：2.1.8 版及以上定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。<br> v-leave：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。

                    <br> v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。

                    <br> v-leave-to：2.1.8 版及以上定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。</li>
                <li>result 属性包含由被指定事件触发的事件处理器返回的最后一个值，除非这个值未定义。</li>
                <li>getContext() 方法返回一个用于在画布上绘图的环境。参数 contextID 指定了您想要在画布上绘制的类型。当前唯一的合法值是 "2d"，它指定了二维绘图，并且导致这个方法返回一个环境对象，该对象导出一个二维绘图 API。</li>
                <li>visible 选择器选取当前可见的每个元素。</li>
                <li>offsetX、offsetY: 鼠标相对于事件源元素（srcElement）的X,Y坐标</li>
                <li>rect() 方法创建矩形。</li>
                <li>closePath() 方法创建从当前点到开始点的路径。</li>
                <li>arc() 方法创建弧/曲线（用于创建圆或部分圆）。</li>
                <li>beginPath() 方法开始一条路径，或重置当前的路径。</li>
                <li>fill() 方法用于将一个固定值替换数组的元素。</li>
                <li>fillText() 方法在画布上绘制填色的文本。文本的默认颜色是黑色</li>
                <li>1.键盘按下事件：keydown() 是在键盘按下就会触发 2.键盘弹起事件：keyup() 是在键盘松手就会触发</li>
                <li>filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。</li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
                <li></li>
            </ul>
        </div>
    </div>

</body>

</html>